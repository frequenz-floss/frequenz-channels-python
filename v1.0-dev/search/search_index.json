{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Channels for Python","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Frequenz Channels is a channels implementation for Python.</p> <p>According to Wikipedia:</p> <p>A channel is a model for interprocess communication and synchronization via message passing. A message may be sent over a channel, and another process or thread is able to receive messages sent over a channel it has a reference to, as a stream. Different implementations of channels may be buffered or not, and either synchronous or asynchronous.</p> <p>Frequenz Channels are mostly designed after Go channels but it also borrows ideas from Rust channels.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul> <p>Note</p> <p>Newer Python versions and other operating systems and architectures might work too, but they are not automatically tested, so we cannot guarantee it.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installing","title":"Installing","text":"<p>Assuming a supported working Python environment:</p> <pre><code>python3 -m pip install frequenz-channels\n</code></pre> <p>Tip</p> <p>For more details please read the Installation Guide.</p>"},{"location":"#examples","title":"Examples","text":"<p>Hello World</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Anycast\n\n\nasync def main() -&gt; None:\n    hello_channel = Anycast[str](name=\"hello-world-channel\")\n    sender = hello_channel.new_sender()\n    receiver = hello_channel.new_receiver()\n\n    await sender.send(\"Hello World!\")\n    message = await receiver.receive()\n    print(message)\n\n\nasyncio.run(main())\n</code></pre> <p>Showcase</p> <p>This is a comprehensive example that shows most of the main features of the library:</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom datetime import timedelta\nfrom enum import Enum, auto\nfrom typing import assert_never\n\nfrom frequenz.channels import (\n    Anycast,\n    Broadcast,\n    Receiver,\n    Sender,\n    merge,\n    select,\n    selected_from,\n)\nfrom frequenz.channels.timer import SkipMissedAndDrift, Timer, TriggerAllMissed\n\n\nclass Command(Enum):\n    PING = auto()\n    STOP_SENDER = auto()\n\n\nclass ReplyCommand(Enum):\n    PONG = auto()\n\n\n@dataclass(frozen=True)\nclass Reply:\n    reply: ReplyCommand\n    source: str\n\n\nasync def send(\n    sender: Sender[str],\n    control_command: Receiver[Command],\n    control_reply: Sender[Reply],\n) -&gt; None:\n    \"\"\"Send a counter value every second, until a stop command is received.\"\"\"\n    print(f\"{sender}: Starting\")\n    timer = Timer(timedelta(seconds=1.0), TriggerAllMissed())\n    counter = 0\n    async for selected in select(timer, control_command):\n        if selected_from(selected, timer):\n            print(f\"{sender}: Sending {counter}\")\n            await sender.send(f\"{sender}: {counter}\")\n            counter += 1\n        elif selected_from(selected, control_command):\n            print(f\"{sender}: Received command: {selected.message.name}\")\n            match selected.message:\n                case Command.STOP_SENDER:\n                    print(f\"{sender}: Stopping\")\n                    break\n                case Command.PING:\n                    print(f\"{sender}: Ping received, reply with pong\")\n                    await control_reply.send(Reply(ReplyCommand.PONG, str(sender)))\n                case _ as unknown:\n                    assert_never(unknown)\n    print(f\"{sender}: Finished\")\n\n\nasync def receive(\n    receivers: list[Receiver[str]],\n    control_command: Receiver[Command],\n    control_reply: Sender[Reply],\n) -&gt; None:\n    \"\"\"Receive data from multiple channels, until no more data is received for 2 seconds.\"\"\"\n    print(\"receive: Starting\")\n    timer = Timer(timedelta(seconds=2.0), SkipMissedAndDrift())\n    print(f\"{timer=}\")\n    merged = merge(*receivers)\n    async for selected in select(merged, timer, control_command):\n        if selected_from(selected, merged):\n            message = selected.message\n            print(f\"receive: Received {message=}\")\n            timer.reset()\n            print(f\"{timer=}\")\n        elif selected_from(selected, control_command):\n            print(f\"receive: received command: {selected.message.name}\")\n            match selected.message:\n                case Command.PING:\n                    print(\"receive: Ping received, reply with pong\")\n                    await control_reply.send(Reply(ReplyCommand.PONG, \"receive\"))\n                case Command.STOP_SENDER:\n                    pass  # Ignore\n                case _ as unknown:\n                    assert_never(unknown)\n        elif selected_from(selected, timer):\n            drift = selected.message\n            print(\n                f\"receive: No data received for {timer.interval + drift} seconds, \"\n                \"giving up\"\n            )\n            break\n    print(\"receive: Finished\")\n\n\nasync def main() -&gt; None:\n    data_channel_1 = Anycast[str](name=\"data-channel-1\")\n    data_channel_2 = Anycast[str](name=\"data-channel-2\")\n    command_channel = Broadcast[Command](name=\"control-channel\")  # (1)!\n    reply_channel = Anycast[Reply](name=\"reply-channel\")\n\n    async with asyncio.TaskGroup() as tasks:\n        tasks.create_task(\n            send(\n                data_channel_1.new_sender(),\n                command_channel.new_receiver(),\n                reply_channel.new_sender(),\n            ),\n            name=\"send-channel-1\",\n        )\n        tasks.create_task(\n            send(\n                data_channel_2.new_sender(),\n                command_channel.new_receiver(),\n                reply_channel.new_sender(),\n            ),\n            name=\"send-channel-2\",\n        )\n        tasks.create_task(\n            receive(\n                [data_channel_1.new_receiver(), data_channel_2.new_receiver()],\n                command_channel.new_receiver(),\n                reply_channel.new_sender(),\n            ),\n            name=\"receive\",\n        )\n\n        control_sender = command_channel.new_sender()\n        reply_receiver = reply_channel.new_receiver()\n\n        # Send a ping command to all tasks and wait for the replies\n        await control_sender.send(Command.PING)\n        print(f\"main: {await reply_receiver.receive()}\")\n        print(f\"main: {await reply_receiver.receive()}\")\n        print(f\"main: {await reply_receiver.receive()}\")\n\n        await asyncio.sleep(5.0)\n\n        # Stop senders, after 2 seconds not receiving any data,\n        # the receiver will stop too\n        await control_sender.send(Command.STOP_SENDER)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz channels","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>User Guide</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>channels<ul> <li>event</li> <li>file_watcher</li> <li>timer</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/channels/","title":"Index","text":""},{"location":"reference/frequenz/channels/#frequenz.channels","title":"frequenz.channels","text":"<p>Frequenz Channels.</p> <p>This package contains channel implementations.</p> <p>Base classes:</p> <ul> <li> <p>Receiver: An object that can wait for and   consume messages from a channel.</p> </li> <li> <p>Sender: An object that can send messages to   a channel.</p> </li> </ul> <p>Channels:</p> <ul> <li> <p>Anycast: A channel that supports multiple   senders and multiple receivers.  A message sent through a sender will be   received by exactly one receiver.</p> </li> <li> <p>Broadcast: A channel to broadcast messages   from multiple senders to multiple receivers. Each message sent through any of   the senders is received by all of the receivers.</p> </li> </ul> <p>Utilities to work with channels:</p> <ul> <li> <p>merge: Merge messages coming from multiple receivers into   a single stream.</p> </li> <li> <p>select: Iterate over the messages of all   receivers as new messages become available.</p> </li> </ul> <p>Exception classes:</p> <ul> <li> <p>Error: Base class for all errors in this   library.</p> </li> <li> <p>ChannelError: Base class for all errors   related to channels.</p> </li> <li> <p>ChannelClosedError: Error raised when   trying to operate (send, receive, etc.) through a closed channel.</p> </li> <li> <p>SenderError: Base class for all errors   related to senders.</p> </li> <li> <p>ReceiverError: Base class for all errors   related to receivers.</p> </li> <li> <p>ReceiverStoppedError: A receiver   stopped producing messages.</p> </li> <li> <p>SelectError: Base class for all errors     related to select.</p> </li> <li> <p>UnhandledSelectedError: An error     raised by select that was not handled by the     user.</p> </li> </ul> <p>Extra utility receivers:</p> <ul> <li> <p>Event: A receiver that generates a message when   an event is set.</p> </li> <li> <p>FileWatcher: A receiver that   generates a message when a file is added, modified or deleted.</p> </li> <li> <p>Timer: A receiver that generates a message after a   given amount of time.</p> </li> </ul>"},{"location":"reference/frequenz/channels/#frequenz.channels-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelMessageT","title":"frequenz.channels.ChannelMessageT  <code>module-attribute</code>","text":"<pre><code>ChannelMessageT = TypeVar('ChannelMessageT')\n</code></pre> <p>The type of the message that can be sent across a channel.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.ErroredChannelT_co","title":"frequenz.channels.ErroredChannelT_co  <code>module-attribute</code>","text":"<pre><code>ErroredChannelT_co = TypeVar(\n    \"ErroredChannelT_co\", covariant=True\n)\n</code></pre> <p>The type of channel having an error.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.MappedMessageT_co","title":"frequenz.channels.MappedMessageT_co  <code>module-attribute</code>","text":"<pre><code>MappedMessageT_co = TypeVar(\n    \"MappedMessageT_co\", covariant=True\n)\n</code></pre> <p>The type of the message received by the receiver after being mapped.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverMessageT_co","title":"frequenz.channels.ReceiverMessageT_co  <code>module-attribute</code>","text":"<pre><code>ReceiverMessageT_co = TypeVar(\n    \"ReceiverMessageT_co\", covariant=True\n)\n</code></pre> <p>The type of the message received by a receiver.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.SenderMessageT_co","title":"frequenz.channels.SenderMessageT_co  <code>module-attribute</code>","text":"<pre><code>SenderMessageT_co = TypeVar(\n    \"SenderMessageT_co\", covariant=True\n)\n</code></pre> <p>The type of the message sent by a sender.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.SenderMessageT_contra","title":"frequenz.channels.SenderMessageT_contra  <code>module-attribute</code>","text":"<pre><code>SenderMessageT_contra = TypeVar(\n    \"SenderMessageT_contra\", contravariant=True\n)\n</code></pre> <p>The type of the message sent by a sender.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels-classes","title":"Classes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast","title":"frequenz.channels.Anycast","text":"<p>             Bases: <code>Generic[ChannelMessageT]</code></p> <p>A channel that delivers each message to exactly one receiver.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast--description","title":"Description","text":"<p>Tip</p> <p>Anycast channels behave like the Golang channels.</p> <p>Anycast channels support multiple senders and multiple receivers. Each message sent through any of the senders will be received by exactly one receiver (but any receiver).</p> <p> <p> Receiver Receiver msg1 msg1 Sender Channel Sender msg2 msg2 </p> <p></p> <p>Characteristics</p> <ul> <li>Buffered: Yes, with a global channel buffer</li> <li>Buffer full policy: Block senders</li> <li>Multiple receivers: Yes</li> <li>Multiple senders: Yes</li> <li>Thread-safe: No</li> </ul> <p>This channel is buffered, and if the senders are faster than the receivers, then the channel's buffer will fill up. In that case, the senders will block at the <code>send()</code> method until the receivers consume the messages in the channel's buffer. The channel's buffer size can be configured at creation time via the <code>limit</code> argument.</p> <p>The first receiver that is awaited will get the next message. When multiple receivers are waiting, the asyncio loop scheduler picks a receiver for each next massage.</p> <p>This means that, in practice, there might be only one receiver receiving all the messages, depending on how tasks are schduled.</p> <p>If you need to ensure some delivery policy (like round-robin or uniformly random), then you will have to implement it yourself.</p> <p>To create a new senders and receivers you can use the <code>new_sender()</code> and <code>new_receiver()</code> methods respectively.</p> <p>When the channel is not needed anymore, it should be closed with the <code>close()</code> method. This will prevent further attempts to <code>send()</code> data. Receivers will still be able to drain the pending messages on the channel, but after that, subsequent <code>receive()</code> calls will raise a <code>ReceiverStoppedError</code> exception.</p> <p>This channel is useful, for example, to distribute work across multiple workers.</p> <p>In cases where each message need to be received by every receiver, a broadcast channel may be used.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast--examples","title":"Examples","text":"Send a few numbers to a receiver <p>This is a very simple example that sends a few numbers from a single sender to a single receiver.</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Anycast, Sender\n\n\nasync def send(sender: Sender[int]) -&gt; None:\n    for message in range(3):\n        print(f\"sending {message}\")\n        await sender.send(message)\n\n\nasync def main() -&gt; None:\n    channel = Anycast[int](name=\"numbers\")\n\n    sender = channel.new_sender()\n    receiver = channel.new_receiver()\n\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(send(sender))\n        for _ in range(3):\n            message = await receiver.receive()\n            print(f\"received {message}\")\n            await asyncio.sleep(0.1)  # sleep (or work) with the data\n\n\nasyncio.run(main())\n</code></pre> <p>The output should look something like (although the sending and received might appear more interleaved):</p> <pre><code>sending 0\nsending 1\nsending 2\nreceived 0\nreceived 1\nreceived 2\n</code></pre> Send a few number from multiple senders to multiple receivers <p>This is a more complex example that sends a few numbers from multiple senders to multiple receivers, using a small buffer to force the senders to block.</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Anycast, Receiver, ReceiverStoppedError, Sender\n\n\nasync def send(name: str, sender: Sender[int], start: int, stop: int) -&gt; None:\n    for message in range(start, stop):\n        print(f\"{name} sending {message}\")\n        await sender.send(message)\n\n\nasync def recv(name: str, receiver: Receiver[int]) -&gt; None:\n    try:\n        async for message in receiver:\n            print(f\"{name} received {message}\")\n        await asyncio.sleep(0.1)  # sleep (or work) with the data\n    except ReceiverStoppedError:\n        pass\n\n\nasync def main() -&gt; None:\n    acast = Anycast[int](name=\"numbers\", limit=2)\n\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(send(\"sender_1\", acast.new_sender(), 10, 13))\n        task_group.create_task(send(\"sender_2\", acast.new_sender(), 20, 22))\n        task_group.create_task(recv(\"receiver_1\", acast.new_receiver()))\n        task_group.create_task(recv(\"receiver_2\", acast.new_receiver()))\n\n\nasyncio.run(main())\n</code></pre> <p>The output should look something like this(although the sending and received might appear interleaved in a different way):</p> <pre><code>sender_1 sending 10\nsender_1 sending 11\nsender_1 sending 12\nAnycast channel [Anycast:numbers:_Sender] is full, blocking sender until a receiver\nconsumes a message\nsender_2 sending 20\nAnycast channel [Anycast:numbers:_Sender] is full, blocking sender until a receiver\nconsumes a message\nreceiver_1 received 10\nreceiver_1 received 11\nsender_2 sending 21\nAnycast channel [Anycast:numbers:_Sender] is full, blocking sender until a receiver\nconsumes a message\nreceiver_1 received 12\nreceiver_1 received 20\nreceiver_1 received 21\n</code></pre> Source code in <code>frequenz/channels/_anycast.py</code> <pre><code>class Anycast(Generic[ChannelMessageT]):\n    \"\"\"A channel that delivers each message to exactly one receiver.\n\n    # Description\n\n    !!! Tip inline end\n\n        [Anycast][frequenz.channels.Anycast] channels behave like the\n        [Golang](https://golang.org/) [channels](https://go.dev/ref/spec#Channel_types).\n\n    [Anycast][frequenz.channels.Anycast] channels support multiple\n    [senders][frequenz.channels.Sender] and multiple\n    [receivers][frequenz.channels.Receiver]. Each message sent through any of the\n    senders will be received by exactly one receiver (but **any** receiver).\n\n    &lt;center&gt;\n    ```bob\n    .---------. msg1                           msg1  .-----------.\n    | Sender  +------.                       .------&gt;| Receiver  |\n    '---------'      |      .----------.     |       '-----------'\n                     +-----&gt;| Channel  +-----+\n    .---------.      |      '----------'     |       .-----------.\n    | Sender  +------'                       '------&gt;| Receiver  |\n    '---------' msg2                           msg2  '-----------'\n    ```\n    &lt;/center&gt;\n\n    !!! Note inline end \"Characteristics\"\n\n        * **Buffered:** Yes, with a global channel buffer\n        * **Buffer full policy:** Block senders\n        * **Multiple receivers:** Yes\n        * **Multiple senders:** Yes\n        * **Thread-safe:** No\n\n    This channel is buffered, and if the senders are faster than the receivers, then the\n    channel's buffer will fill up. In that case, the senders will block at the\n    [`send()`][frequenz.channels.Sender.send] method until the receivers consume the\n    messages in the channel's buffer. The channel's buffer size can be configured at\n    creation time via the `limit` argument.\n\n    The first receiver that is awaited will get the next message. When multiple\n    receivers are waiting, the [asyncio][] loop scheduler picks a receiver for each next\n    massage.\n\n    This means that, in practice, there might be only one receiver receiving all the\n    messages, depending on how tasks are schduled.\n\n    If you need to ensure some delivery policy (like round-robin or uniformly random),\n    then you will have to implement it yourself.\n\n    To create a new [senders][frequenz.channels.Sender] and\n    [receivers][frequenz.channels.Receiver] you can use the\n    [`new_sender()`][frequenz.channels.Broadcast.new_sender] and\n    [`new_receiver()`][frequenz.channels.Broadcast.new_receiver] methods\n    respectively.\n\n    When the channel is not needed anymore, it should be closed with the\n    [`close()`][frequenz.channels.Anycast.close] method. This will prevent further\n    attempts to [`send()`][frequenz.channels.Sender.send] data. Receivers will still be\n    able to drain the pending messages on the channel, but after that, subsequent\n    [`receive()`][frequenz.channels.Receiver.receive] calls will raise a\n    [`ReceiverStoppedError`][frequenz.channels.ReceiverStoppedError] exception.\n\n    This channel is useful, for example, to distribute work across multiple workers.\n\n    In cases where each message need to be received by every receiver, a\n    [broadcast][frequenz.channels.Broadcast] channel may be used.\n\n    # Examples\n\n    Example: Send a few numbers to a receiver\n        This is a very simple example that sends a few numbers from a single sender to\n        a single receiver.\n\n        ```python\n        import asyncio\n\n        from frequenz.channels import Anycast, Sender\n\n\n        async def send(sender: Sender[int]) -&gt; None:\n            for message in range(3):\n                print(f\"sending {message}\")\n                await sender.send(message)\n\n\n        async def main() -&gt; None:\n            channel = Anycast[int](name=\"numbers\")\n\n            sender = channel.new_sender()\n            receiver = channel.new_receiver()\n\n            async with asyncio.TaskGroup() as task_group:\n                task_group.create_task(send(sender))\n                for _ in range(3):\n                    message = await receiver.receive()\n                    print(f\"received {message}\")\n                    await asyncio.sleep(0.1)  # sleep (or work) with the data\n\n\n        asyncio.run(main())\n        ```\n\n        The output should look something like (although the sending and received might\n        appear more interleaved):\n\n        ```\n        sending 0\n        sending 1\n        sending 2\n        received 0\n        received 1\n        received 2\n        ```\n\n    Example: Send a few number from multiple senders to multiple receivers\n        This is a more complex example that sends a few numbers from multiple senders to\n        multiple receivers, using a small buffer to force the senders to block.\n\n        ```python\n        import asyncio\n\n        from frequenz.channels import Anycast, Receiver, ReceiverStoppedError, Sender\n\n\n        async def send(name: str, sender: Sender[int], start: int, stop: int) -&gt; None:\n            for message in range(start, stop):\n                print(f\"{name} sending {message}\")\n                await sender.send(message)\n\n\n        async def recv(name: str, receiver: Receiver[int]) -&gt; None:\n            try:\n                async for message in receiver:\n                    print(f\"{name} received {message}\")\n                await asyncio.sleep(0.1)  # sleep (or work) with the data\n            except ReceiverStoppedError:\n                pass\n\n\n        async def main() -&gt; None:\n            acast = Anycast[int](name=\"numbers\", limit=2)\n\n            async with asyncio.TaskGroup() as task_group:\n                task_group.create_task(send(\"sender_1\", acast.new_sender(), 10, 13))\n                task_group.create_task(send(\"sender_2\", acast.new_sender(), 20, 22))\n                task_group.create_task(recv(\"receiver_1\", acast.new_receiver()))\n                task_group.create_task(recv(\"receiver_2\", acast.new_receiver()))\n\n\n        asyncio.run(main())\n        ```\n\n        The output should look something like this(although the sending and received\n        might appear interleaved in a different way):\n\n        ```\n        sender_1 sending 10\n        sender_1 sending 11\n        sender_1 sending 12\n        Anycast channel [Anycast:numbers:_Sender] is full, blocking sender until a receiver\n        consumes a message\n        sender_2 sending 20\n        Anycast channel [Anycast:numbers:_Sender] is full, blocking sender until a receiver\n        consumes a message\n        receiver_1 received 10\n        receiver_1 received 11\n        sender_2 sending 21\n        Anycast channel [Anycast:numbers:_Sender] is full, blocking sender until a receiver\n        consumes a message\n        receiver_1 received 12\n        receiver_1 received 20\n        receiver_1 received 21\n        ```\n    \"\"\"\n\n    def __init__(self, *, name: str, limit: int = 10) -&gt; None:\n        \"\"\"Initialize this channel.\n\n        Args:\n            name: The name of the channel. This is for logging purposes, and it will be\n                shown in the string representation of the channel.\n            limit: The size of the internal buffer in number of messages.  If the buffer\n                is full, then the senders will block until the receivers consume the\n                messages in the buffer.\n        \"\"\"\n        self._name: str = name\n        \"\"\"The name of the channel.\n\n        This is for logging purposes, and it will be shown in the string representation\n        of the channel.\n        \"\"\"\n\n        self._deque: deque[ChannelMessageT] = deque(maxlen=limit)\n        \"\"\"The channel's buffer.\"\"\"\n\n        self._send_cv: Condition = Condition()\n        \"\"\"The condition to wait for free space in the channel's buffer.\n\n        If the channel's buffer is full, then the sender waits for messages to\n        get consumed using this condition until there's some free space\n        available in the channel's buffer.\n        \"\"\"\n\n        self._recv_cv: Condition = Condition()\n        \"\"\"The condition to wait for messages in the channel's buffer.\n\n        If the channel's buffer is empty, then the receiver waits for messages\n        using this condition until there's a message available in the channel's\n        buffer.\n        \"\"\"\n\n        self._closed: bool = False\n        \"\"\"Whether the channel is closed.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of this channel.\n\n        This is for debugging purposes, it will be shown in the string representation\n        of this channel.\n        \"\"\"\n        return self._name\n\n    @property\n    def is_closed(self) -&gt; bool:\n        \"\"\"Whether this channel is closed.\n\n        Any further attempts to use this channel after it is closed will result in an\n        exception.\n        \"\"\"\n        return self._closed\n\n    @property\n    def limit(self) -&gt; int:\n        \"\"\"The maximum number of messages that can be stored in the channel's buffer.\n\n        If the length of channel's buffer reaches the limit, then the sender\n        blocks at the [send()][frequenz.channels.Sender.send] method until\n        a message is consumed.\n        \"\"\"\n        maxlen = self._deque.maxlen\n        assert maxlen is not None\n        return maxlen\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the channel.\n\n        Any further attempts to [send()][frequenz.channels.Sender.send] data\n        will return `False`.\n\n        Receivers will still be able to drain the pending messages on the channel,\n        but after that, subsequent\n        [receive()][frequenz.channels.Receiver.receive] calls will return `None`\n        immediately.\n        \"\"\"\n        self._closed = True\n        async with self._send_cv:\n            self._send_cv.notify_all()\n        async with self._recv_cv:\n            self._recv_cv.notify_all()\n\n    def new_sender(self) -&gt; Sender[ChannelMessageT]:\n        \"\"\"Return a new sender attached to this channel.\"\"\"\n        return _Sender(self)\n\n    def new_receiver(self) -&gt; Receiver[ChannelMessageT]:\n        \"\"\"Return a new receiver attached to this channel.\"\"\"\n        return _Receiver(self)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this channel.\"\"\"\n        return f\"{type(self).__name__}:{self._name}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this channel.\"\"\"\n        return (\n            f\"{type(self).__name__}(name={self._name!r}, limit={self.limit!r}):&lt;\"\n            f\"current={len(self._deque)!r}, closed={self._closed!r}&gt;\"\n        )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.is_closed","title":"is_closed  <code>property</code>","text":"<pre><code>is_closed: bool\n</code></pre> <p>Whether this channel is closed.</p> <p>Any further attempts to use this channel after it is closed will result in an exception.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.limit","title":"limit  <code>property</code>","text":"<pre><code>limit: int\n</code></pre> <p>The maximum number of messages that can be stored in the channel's buffer.</p> <p>If the length of channel's buffer reaches the limit, then the sender blocks at the send() method until a message is consumed.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this channel.</p> <p>This is for debugging purposes, it will be shown in the string representation of this channel.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str, limit: int = 10) -&gt; None\n</code></pre> <p>Initialize this channel.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of the channel. This is for logging purposes, and it will be shown in the string representation of the channel.</p> <p> TYPE: <code>str</code> </p> <code>limit</code> <p>The size of the internal buffer in number of messages.  If the buffer is full, then the senders will block until the receivers consume the messages in the buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> Source code in <code>frequenz/channels/_anycast.py</code> <pre><code>def __init__(self, *, name: str, limit: int = 10) -&gt; None:\n    \"\"\"Initialize this channel.\n\n    Args:\n        name: The name of the channel. This is for logging purposes, and it will be\n            shown in the string representation of the channel.\n        limit: The size of the internal buffer in number of messages.  If the buffer\n            is full, then the senders will block until the receivers consume the\n            messages in the buffer.\n    \"\"\"\n    self._name: str = name\n    \"\"\"The name of the channel.\n\n    This is for logging purposes, and it will be shown in the string representation\n    of the channel.\n    \"\"\"\n\n    self._deque: deque[ChannelMessageT] = deque(maxlen=limit)\n    \"\"\"The channel's buffer.\"\"\"\n\n    self._send_cv: Condition = Condition()\n    \"\"\"The condition to wait for free space in the channel's buffer.\n\n    If the channel's buffer is full, then the sender waits for messages to\n    get consumed using this condition until there's some free space\n    available in the channel's buffer.\n    \"\"\"\n\n    self._recv_cv: Condition = Condition()\n    \"\"\"The condition to wait for messages in the channel's buffer.\n\n    If the channel's buffer is empty, then the receiver waits for messages\n    using this condition until there's a message available in the channel's\n    buffer.\n    \"\"\"\n\n    self._closed: bool = False\n    \"\"\"Whether the channel is closed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this channel.</p> Source code in <code>frequenz/channels/_anycast.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this channel.\"\"\"\n    return (\n        f\"{type(self).__name__}(name={self._name!r}, limit={self.limit!r}):&lt;\"\n        f\"current={len(self._deque)!r}, closed={self._closed!r}&gt;\"\n    )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this channel.</p> Source code in <code>frequenz/channels/_anycast.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this channel.\"\"\"\n    return f\"{type(self).__name__}:{self._name}\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the channel.</p> <p>Any further attempts to send() data will return <code>False</code>.</p> <p>Receivers will still be able to drain the pending messages on the channel, but after that, subsequent receive() calls will return <code>None</code> immediately.</p> Source code in <code>frequenz/channels/_anycast.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the channel.\n\n    Any further attempts to [send()][frequenz.channels.Sender.send] data\n    will return `False`.\n\n    Receivers will still be able to drain the pending messages on the channel,\n    but after that, subsequent\n    [receive()][frequenz.channels.Receiver.receive] calls will return `None`\n    immediately.\n    \"\"\"\n    self._closed = True\n    async with self._send_cv:\n        self._send_cv.notify_all()\n    async with self._recv_cv:\n        self._recv_cv.notify_all()\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver() -&gt; Receiver[ChannelMessageT]\n</code></pre> <p>Return a new receiver attached to this channel.</p> Source code in <code>frequenz/channels/_anycast.py</code> <pre><code>def new_receiver(self) -&gt; Receiver[ChannelMessageT]:\n    \"\"\"Return a new receiver attached to this channel.\"\"\"\n    return _Receiver(self)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast.new_sender","title":"new_sender","text":"<pre><code>new_sender() -&gt; Sender[ChannelMessageT]\n</code></pre> <p>Return a new sender attached to this channel.</p> Source code in <code>frequenz/channels/_anycast.py</code> <pre><code>def new_sender(self) -&gt; Sender[ChannelMessageT]:\n    \"\"\"Return a new sender attached to this channel.\"\"\"\n    return _Sender(self)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast","title":"frequenz.channels.Broadcast","text":"<p>             Bases: <code>Generic[ChannelMessageT]</code></p> <p>A channel that deliver all messages to all receivers.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast--description","title":"Description","text":"<p>Broadcast channels can have multiple senders and multiple receivers. Each message sent through any of the senders will be received by all receivers.</p> <p> <p> Receiver Receiver msg1 msg1,msg2 Sender Channel Sender msg2 msg1,msg2 </p> <p></p> <p>Characteristics</p> <ul> <li>Buffered: Yes, with one buffer per receiver</li> <li>Buffer full policy: Drop oldest message</li> <li>Multiple receivers: Yes</li> <li>Multiple senders: Yes</li> <li>Thread-safe: No</li> </ul> <p>This channel is buffered, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped.</p> <p>Each receiver has its own buffer, so messages will only be dropped for receivers that can't keep up with the senders, and not for the whole channel.</p> <p>To create a new senders and receivers you can use the <code>new_sender()</code> and <code>new_receiver()</code> methods respectively.</p> <p>When a channel is not needed anymore, it should be closed with <code>close()</code>. This will prevent further attempts to <code>send()</code> data, and will allow receivers to drain the pending items on their queues, but after that, subsequent receive() calls will raise a <code>ReceiverStoppedError</code>.</p> <p>This channel is useful, for example, to implement a pub/sub pattern, where multiple receivers can subscribe to a channel to receive all messages.</p> <p>In cases where each message needs to be delivered only to one receiver, an anycast channel may be used.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast--examples","title":"Examples","text":"Send a few numbers to a receiver <p>This is a very simple example that sends a few numbers from a single sender to a single receiver.</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Sender\n\n\nasync def send(sender: Sender[int]) -&gt; None:\n    for message in range(3):\n        print(f\"sending {message}\")\n        await sender.send(message)\n\n\nasync def main() -&gt; None:\n    channel = Broadcast[int](name=\"numbers\")\n\n    sender = channel.new_sender()\n    receiver = channel.new_receiver()\n\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(send(sender))\n        for _ in range(3):\n            message = await receiver.receive()\n            print(f\"received {message}\")\n            await asyncio.sleep(0.1)  # sleep (or work) with the data\n\n\nasyncio.run(main())\n</code></pre> <p>The output should look something like (although the sending and received might appear more interleaved):</p> <pre><code>sending 0\nsending 1\nsending 2\nreceived 0\nreceived 1\nreceived 2\n</code></pre> Send a few number from multiple senders to multiple receivers <p>This is a more complex example that sends a few numbers from multiple senders to multiple receivers, using a small buffer to force the senders to block.</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, ReceiverStoppedError, Sender\n\n\nasync def send(name: str, sender: Sender[int], start: int, stop: int) -&gt; None:\n    for message in range(start, stop):\n        print(f\"{name} sending {message}\")\n        await sender.send(message)\n\n\nasync def recv(name: str, receiver: Receiver[int]) -&gt; None:\n    try:\n        async for message in receiver:\n            print(f\"{name} received {message}\")\n        await asyncio.sleep(0.1)  # sleep (or work) with the data\n    except ReceiverStoppedError:\n        pass\n\n\nasync def main() -&gt; None:\n    acast = Broadcast[int](name=\"numbers\")\n\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(send(\"sender_1\", acast.new_sender(), 10, 13))\n        task_group.create_task(send(\"sender_2\", acast.new_sender(), 20, 22))\n        task_group.create_task(recv(\"receiver_1\", acast.new_receiver()))\n        task_group.create_task(recv(\"receiver_2\", acast.new_receiver()))\n\n\nasyncio.run(main())\n</code></pre> <p>The output should look something like this(although the sending and received might appear interleaved in a different way):</p> <pre><code>sender_1 sending 10\nsender_1 sending 11\nsender_1 sending 12\nsender_2 sending 20\nsender_2 sending 21\nreceiver_1 received 10\nreceiver_1 received 11\nreceiver_1 received 12\nreceiver_1 received 20\nreceiver_1 received 21\nreceiver_2 received 10\nreceiver_2 received 11\nreceiver_2 received 12\nreceiver_2 received 20\nreceiver_2 received 21\n</code></pre> Source code in <code>frequenz/channels/_broadcast.py</code> <pre><code>class Broadcast(Generic[ChannelMessageT]):\n    \"\"\"A channel that deliver all messages to all receivers.\n\n    # Description\n\n    [Broadcast][frequenz.channels.Broadcast] channels can have multiple\n    [senders][frequenz.channels.Sender] and multiple\n    [receivers][frequenz.channels.Receiver]. Each message sent through any of the\n    senders will be received by all receivers.\n\n    &lt;center&gt;\n    ```bob\n    .---------. msg1                           msg1,msg2  .-----------.\n    | Sender  +------.                        .----------&gt;| Receiver  |\n    '---------'      |      .----------.     |            '-----------'\n                     +-----&gt;| Channel  +-----+\n    .---------.      |      '----------'     |            .-----------.\n    | Sender  +------'                       '-----------&gt;| Receiver  |\n    '---------' msg2                           msg1,msg2  '-----------'\n    ```\n    &lt;/center&gt;\n\n    !!! Note inline end \"Characteristics\"\n\n        * **Buffered:** Yes, with one buffer per receiver\n        * **Buffer full policy:** Drop oldest message\n        * **Multiple receivers:** Yes\n        * **Multiple senders:** Yes\n        * **Thread-safe:** No\n\n    This channel is buffered, and when messages are not being consumed fast\n    enough and the buffer fills up, old messages will get dropped.\n\n    Each receiver has its own buffer, so messages will only be dropped for\n    receivers that can't keep up with the senders, and not for the whole\n    channel.\n\n    To create a new [senders][frequenz.channels.Sender] and\n    [receivers][frequenz.channels.Receiver] you can use the\n    [`new_sender()`][frequenz.channels.Broadcast.new_sender] and\n    [`new_receiver()`][frequenz.channels.Broadcast.new_receiver] methods\n    respectively.\n\n    When a channel is not needed anymore, it should be closed with\n    [`close()`][frequenz.channels.Broadcast.close]. This will prevent further\n    attempts to [`send()`][frequenz.channels.Sender.send] data, and will allow\n    receivers to drain the pending items on their queues, but after that,\n    subsequent [receive()][frequenz.channels.Receiver.receive] calls will\n    raise a [`ReceiverStoppedError`][frequenz.channels.ReceiverStoppedError].\n\n    This channel is useful, for example, to implement a pub/sub pattern, where\n    multiple receivers can subscribe to a channel to receive all messages.\n\n    In cases where each message needs to be delivered only to one receiver, an\n    [anycast][frequenz.channels.Anycast] channel may be used.\n\n    # Examples\n\n    Example: Send a few numbers to a receiver\n        This is a very simple example that sends a few numbers from a single sender to\n        a single receiver.\n\n        ```python\n        import asyncio\n\n        from frequenz.channels import Broadcast, Sender\n\n\n        async def send(sender: Sender[int]) -&gt; None:\n            for message in range(3):\n                print(f\"sending {message}\")\n                await sender.send(message)\n\n\n        async def main() -&gt; None:\n            channel = Broadcast[int](name=\"numbers\")\n\n            sender = channel.new_sender()\n            receiver = channel.new_receiver()\n\n            async with asyncio.TaskGroup() as task_group:\n                task_group.create_task(send(sender))\n                for _ in range(3):\n                    message = await receiver.receive()\n                    print(f\"received {message}\")\n                    await asyncio.sleep(0.1)  # sleep (or work) with the data\n\n\n        asyncio.run(main())\n        ```\n\n        The output should look something like (although the sending and received might\n        appear more interleaved):\n\n        ```\n        sending 0\n        sending 1\n        sending 2\n        received 0\n        received 1\n        received 2\n        ```\n\n    Example: Send a few number from multiple senders to multiple receivers\n        This is a more complex example that sends a few numbers from multiple senders to\n        multiple receivers, using a small buffer to force the senders to block.\n\n        ```python\n        import asyncio\n\n        from frequenz.channels import Broadcast, Receiver, ReceiverStoppedError, Sender\n\n\n        async def send(name: str, sender: Sender[int], start: int, stop: int) -&gt; None:\n            for message in range(start, stop):\n                print(f\"{name} sending {message}\")\n                await sender.send(message)\n\n\n        async def recv(name: str, receiver: Receiver[int]) -&gt; None:\n            try:\n                async for message in receiver:\n                    print(f\"{name} received {message}\")\n                await asyncio.sleep(0.1)  # sleep (or work) with the data\n            except ReceiverStoppedError:\n                pass\n\n\n        async def main() -&gt; None:\n            acast = Broadcast[int](name=\"numbers\")\n\n            async with asyncio.TaskGroup() as task_group:\n                task_group.create_task(send(\"sender_1\", acast.new_sender(), 10, 13))\n                task_group.create_task(send(\"sender_2\", acast.new_sender(), 20, 22))\n                task_group.create_task(recv(\"receiver_1\", acast.new_receiver()))\n                task_group.create_task(recv(\"receiver_2\", acast.new_receiver()))\n\n\n        asyncio.run(main())\n        ```\n\n        The output should look something like this(although the sending and received\n        might appear interleaved in a different way):\n\n        ```\n        sender_1 sending 10\n        sender_1 sending 11\n        sender_1 sending 12\n        sender_2 sending 20\n        sender_2 sending 21\n        receiver_1 received 10\n        receiver_1 received 11\n        receiver_1 received 12\n        receiver_1 received 20\n        receiver_1 received 21\n        receiver_2 received 10\n        receiver_2 received 11\n        receiver_2 received 12\n        receiver_2 received 20\n        receiver_2 received 21\n        ```\n    \"\"\"\n\n    def __init__(self, *, name: str, resend_latest: bool = False) -&gt; None:\n        \"\"\"Initialize this channel.\n\n        Args:\n            name: The name of the channel. This is for logging purposes, and it will be\n                shown in the string representation of the channel.\n            resend_latest: When True, every time a new receiver is created with\n                `new_receiver`, the last message seen by the channel will be sent to the\n                new receiver automatically. This allows new receivers on slow streams to\n                get the latest message as soon as they are created, without having to\n                wait for the next message on the channel to arrive.  It is safe to be\n                set in data/reporting channels, but is not recommended for use in\n                channels that stream control instructions.\n        \"\"\"\n        self._name: str = name\n        \"\"\"The name of the broadcast channel.\n\n        Only used for debugging purposes.\n        \"\"\"\n\n        self._recv_cv: Condition = Condition()\n        \"\"\"The condition to wait for data in the channel's buffer.\"\"\"\n\n        self._receivers: dict[\n            int, weakref.ReferenceType[_Receiver[ChannelMessageT]]\n        ] = {}\n        \"\"\"The receivers attached to the channel, indexed by their hash().\"\"\"\n\n        self._closed: bool = False\n        \"\"\"Whether the channel is closed.\"\"\"\n\n        self._latest: ChannelMessageT | None = None\n        \"\"\"The latest message sent to the channel.\"\"\"\n\n        self.resend_latest: bool = resend_latest\n        \"\"\"Whether to resend the latest message to new receivers.\n\n        When `True`, every time a new receiver is created with `new_receiver`, it will\n        automatically get sent the latest message on the channel.  This allows new\n        receivers on slow streams to get the latest message as soon as they are created,\n        without having to wait for the next message on the channel to arrive.\n\n        It is safe to be set in data/reporting channels, but is not recommended for use\n        in channels that stream control instructions.\n        \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of this channel.\n\n        This is for logging purposes, and it will be shown in the string representation\n        of this channel.\n        \"\"\"\n        return self._name\n\n    @property\n    def is_closed(self) -&gt; bool:\n        \"\"\"Whether this channel is closed.\n\n        Any further attempts to use this channel after it is closed will result in an\n        exception.\n        \"\"\"\n        return self._closed\n\n    async def close(self) -&gt; None:\n        \"\"\"Close this channel.\n\n        Any further attempts to [send()][frequenz.channels.Sender.send] data\n        will return `False`.\n\n        Receivers will still be able to drain the pending items on their queues,\n        but after that, subsequent\n        [receive()][frequenz.channels.Receiver.receive] calls will return `None`\n        immediately.\n        \"\"\"\n        self._latest = None\n        self._closed = True\n        async with self._recv_cv:\n            self._recv_cv.notify_all()\n\n    def new_sender(self) -&gt; Sender[ChannelMessageT]:\n        \"\"\"Return a new sender attached to this channel.\"\"\"\n        return _Sender(self)\n\n    def new_receiver(\n        self, *, name: str | None = None, limit: int = 50\n    ) -&gt; Receiver[ChannelMessageT]:\n        \"\"\"Return a new receiver attached to this channel.\n\n        Broadcast receivers have their own buffer, and when messages are not\n        being consumed fast enough and the buffer fills up, old messages will\n        get dropped just in this receiver.\n\n        Args:\n            name: A name to identify the receiver in the logs.\n            limit: Number of messages the receiver can hold in its buffer.\n\n        Returns:\n            A new receiver attached to this channel.\n        \"\"\"\n        recv: _Receiver[ChannelMessageT] = _Receiver(self, name=name, limit=limit)\n        self._receivers[hash(recv)] = weakref.ref(recv)\n        if self.resend_latest and self._latest is not None:\n            recv.enqueue(self._latest)\n        return recv\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this channel.\"\"\"\n        return f\"{type(self).__name__}:{self._name}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this channel.\"\"\"\n        return (\n            f\"{type(self).__name__}(name={self._name!r}, \"\n            f\"resend_latest={self.resend_latest!r}):&lt;\"\n            f\"latest={self._latest!r}, \"\n            f\"receivers={len(self._receivers)!r}, \"\n            f\"closed={self._closed!r}&gt;\"\n        )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.is_closed","title":"is_closed  <code>property</code>","text":"<pre><code>is_closed: bool\n</code></pre> <p>Whether this channel is closed.</p> <p>Any further attempts to use this channel after it is closed will result in an exception.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this channel.</p> <p>This is for logging purposes, and it will be shown in the string representation of this channel.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.resend_latest","title":"resend_latest  <code>instance-attribute</code>","text":"<pre><code>resend_latest: bool = resend_latest\n</code></pre> <p>Whether to resend the latest message to new receivers.</p> <p>When <code>True</code>, every time a new receiver is created with <code>new_receiver</code>, it will automatically get sent the latest message on the channel.  This allows new receivers on slow streams to get the latest message as soon as they are created, without having to wait for the next message on the channel to arrive.</p> <p>It is safe to be set in data/reporting channels, but is not recommended for use in channels that stream control instructions.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str, resend_latest: bool = False) -&gt; None\n</code></pre> <p>Initialize this channel.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of the channel. This is for logging purposes, and it will be shown in the string representation of the channel.</p> <p> TYPE: <code>str</code> </p> <code>resend_latest</code> <p>When True, every time a new receiver is created with <code>new_receiver</code>, the last message seen by the channel will be sent to the new receiver automatically. This allows new receivers on slow streams to get the latest message as soon as they are created, without having to wait for the next message on the channel to arrive.  It is safe to be set in data/reporting channels, but is not recommended for use in channels that stream control instructions.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>frequenz/channels/_broadcast.py</code> <pre><code>def __init__(self, *, name: str, resend_latest: bool = False) -&gt; None:\n    \"\"\"Initialize this channel.\n\n    Args:\n        name: The name of the channel. This is for logging purposes, and it will be\n            shown in the string representation of the channel.\n        resend_latest: When True, every time a new receiver is created with\n            `new_receiver`, the last message seen by the channel will be sent to the\n            new receiver automatically. This allows new receivers on slow streams to\n            get the latest message as soon as they are created, without having to\n            wait for the next message on the channel to arrive.  It is safe to be\n            set in data/reporting channels, but is not recommended for use in\n            channels that stream control instructions.\n    \"\"\"\n    self._name: str = name\n    \"\"\"The name of the broadcast channel.\n\n    Only used for debugging purposes.\n    \"\"\"\n\n    self._recv_cv: Condition = Condition()\n    \"\"\"The condition to wait for data in the channel's buffer.\"\"\"\n\n    self._receivers: dict[\n        int, weakref.ReferenceType[_Receiver[ChannelMessageT]]\n    ] = {}\n    \"\"\"The receivers attached to the channel, indexed by their hash().\"\"\"\n\n    self._closed: bool = False\n    \"\"\"Whether the channel is closed.\"\"\"\n\n    self._latest: ChannelMessageT | None = None\n    \"\"\"The latest message sent to the channel.\"\"\"\n\n    self.resend_latest: bool = resend_latest\n    \"\"\"Whether to resend the latest message to new receivers.\n\n    When `True`, every time a new receiver is created with `new_receiver`, it will\n    automatically get sent the latest message on the channel.  This allows new\n    receivers on slow streams to get the latest message as soon as they are created,\n    without having to wait for the next message on the channel to arrive.\n\n    It is safe to be set in data/reporting channels, but is not recommended for use\n    in channels that stream control instructions.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this channel.</p> Source code in <code>frequenz/channels/_broadcast.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this channel.\"\"\"\n    return (\n        f\"{type(self).__name__}(name={self._name!r}, \"\n        f\"resend_latest={self.resend_latest!r}):&lt;\"\n        f\"latest={self._latest!r}, \"\n        f\"receivers={len(self._receivers)!r}, \"\n        f\"closed={self._closed!r}&gt;\"\n    )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this channel.</p> Source code in <code>frequenz/channels/_broadcast.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this channel.\"\"\"\n    return f\"{type(self).__name__}:{self._name}\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this channel.</p> <p>Any further attempts to send() data will return <code>False</code>.</p> <p>Receivers will still be able to drain the pending items on their queues, but after that, subsequent receive() calls will return <code>None</code> immediately.</p> Source code in <code>frequenz/channels/_broadcast.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close this channel.\n\n    Any further attempts to [send()][frequenz.channels.Sender.send] data\n    will return `False`.\n\n    Receivers will still be able to drain the pending items on their queues,\n    but after that, subsequent\n    [receive()][frequenz.channels.Receiver.receive] calls will return `None`\n    immediately.\n    \"\"\"\n    self._latest = None\n    self._closed = True\n    async with self._recv_cv:\n        self._recv_cv.notify_all()\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.new_receiver","title":"new_receiver","text":"<pre><code>new_receiver(\n    *, name: str | None = None, limit: int = 50\n) -&gt; Receiver[ChannelMessageT]\n</code></pre> <p>Return a new receiver attached to this channel.</p> <p>Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver.</p> PARAMETER  DESCRIPTION <code>name</code> <p>A name to identify the receiver in the logs.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>limit</code> <p>Number of messages the receiver can hold in its buffer.</p> <p> TYPE: <code>int</code> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Receiver[ChannelMessageT]</code> <p>A new receiver attached to this channel.</p> Source code in <code>frequenz/channels/_broadcast.py</code> <pre><code>def new_receiver(\n    self, *, name: str | None = None, limit: int = 50\n) -&gt; Receiver[ChannelMessageT]:\n    \"\"\"Return a new receiver attached to this channel.\n\n    Broadcast receivers have their own buffer, and when messages are not\n    being consumed fast enough and the buffer fills up, old messages will\n    get dropped just in this receiver.\n\n    Args:\n        name: A name to identify the receiver in the logs.\n        limit: Number of messages the receiver can hold in its buffer.\n\n    Returns:\n        A new receiver attached to this channel.\n    \"\"\"\n    recv: _Receiver[ChannelMessageT] = _Receiver(self, name=name, limit=limit)\n    self._receivers[hash(recv)] = weakref.ref(recv)\n    if self.resend_latest and self._latest is not None:\n        recv.enqueue(self._latest)\n    return recv\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast.new_sender","title":"new_sender","text":"<pre><code>new_sender() -&gt; Sender[ChannelMessageT]\n</code></pre> <p>Return a new sender attached to this channel.</p> Source code in <code>frequenz/channels/_broadcast.py</code> <pre><code>def new_sender(self) -&gt; Sender[ChannelMessageT]:\n    \"\"\"Return a new sender attached to this channel.\"\"\"\n    return _Sender(self)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelClosedError","title":"frequenz.channels.ChannelClosedError","text":"<p>             Bases: <code>ChannelError[ErroredChannelT_co]</code></p> <p>A closed channel was used.</p> Source code in <code>frequenz/channels/_exceptions.py</code> <pre><code>class ChannelClosedError(ChannelError[ErroredChannelT_co]):\n    \"\"\"A closed channel was used.\"\"\"\n\n    def __init__(self, channel: ErroredChannelT_co):\n        \"\"\"Initialize this error.\n\n        Args:\n            channel: The channel that was closed.\n        \"\"\"\n        super().__init__(f\"Channel {channel} was closed\", channel)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelClosedError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelClosedError.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: ErroredChannelT_co = channel\n</code></pre> <p>The channel where the error happened.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelClosedError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelClosedError.__init__","title":"__init__","text":"<pre><code>__init__(channel: ErroredChannelT_co)\n</code></pre> <p>Initialize this error.</p> PARAMETER  DESCRIPTION <code>channel</code> <p>The channel that was closed.</p> <p> TYPE: <code>ErroredChannelT_co</code> </p> Source code in <code>frequenz/channels/_exceptions.py</code> <pre><code>def __init__(self, channel: ErroredChannelT_co):\n    \"\"\"Initialize this error.\n\n    Args:\n        channel: The channel that was closed.\n    \"\"\"\n    super().__init__(f\"Channel {channel} was closed\", channel)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelError","title":"frequenz.channels.ChannelError","text":"<p>             Bases: <code>Error</code>, <code>Generic[ErroredChannelT_co]</code></p> <p>An error that originated in a channel.</p> <p>All exceptions generated by channels inherit from this exception.</p> Source code in <code>frequenz/channels/_exceptions.py</code> <pre><code>class ChannelError(Error, Generic[ErroredChannelT_co]):\n    \"\"\"An error that originated in a channel.\n\n    All exceptions generated by channels inherit from this exception.\n    \"\"\"\n\n    def __init__(self, message: str, channel: ErroredChannelT_co):\n        \"\"\"Initialize this error.\n\n        Args:\n            message: The error message.\n            channel: The channel where the error happened.\n        \"\"\"\n        super().__init__(message)\n        self.channel: ErroredChannelT_co = channel\n        \"\"\"The channel where the error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelError.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: ErroredChannelT_co = channel\n</code></pre> <p>The channel where the error happened.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ChannelError.__init__","title":"__init__","text":"<pre><code>__init__(message: str, channel: ErroredChannelT_co)\n</code></pre> <p>Initialize this error.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p> <code>channel</code> <p>The channel where the error happened.</p> <p> TYPE: <code>ErroredChannelT_co</code> </p> Source code in <code>frequenz/channels/_exceptions.py</code> <pre><code>def __init__(self, message: str, channel: ErroredChannelT_co):\n    \"\"\"Initialize this error.\n\n    Args:\n        message: The error message.\n        channel: The channel where the error happened.\n    \"\"\"\n    super().__init__(message)\n    self.channel: ErroredChannelT_co = channel\n    \"\"\"The channel where the error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Error","title":"frequenz.channels.Error","text":"<p>             Bases: <code>RuntimeError</code></p> <p>An error that originated in this library.</p> <p>This is useful if you want to catch all exceptions generated by this library.</p> Source code in <code>frequenz/channels/_exceptions.py</code> <pre><code>class Error(RuntimeError):\n    \"\"\"An error that originated in this library.\n\n    This is useful if you want to catch all exceptions generated by this library.\n    \"\"\"\n\n    def __init__(self, message: str):\n        \"\"\"Initialize this error.\n\n        Args:\n            message: The error message.\n        \"\"\"\n        super().__init__(message)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Error-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Error.__init__","title":"__init__","text":"<pre><code>__init__(message: str)\n</code></pre> <p>Initialize this error.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p> Source code in <code>frequenz/channels/_exceptions.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"Initialize this error.\n\n    Args:\n        message: The error message.\n    \"\"\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger","title":"frequenz.channels.Merger","text":"<p>             Bases: <code>Receiver[ReceiverMessageT_co]</code></p> <p>A receiver that merges messages coming from multiple receivers into a single stream.</p> Tip <p>Please consider using the more idiomatic <code>merge()</code> function instead of creating a <code>Merger</code> instance directly.</p> Source code in <code>frequenz/channels/_merge.py</code> <pre><code>class Merger(Receiver[ReceiverMessageT_co]):\n    \"\"\"A receiver that merges messages coming from multiple receivers into a single stream.\n\n    Tip:\n        Please consider using the more idiomatic [`merge()`][frequenz.channels.merge]\n        function instead of creating a `Merger` instance directly.\n    \"\"\"\n\n    def __init__(\n        self, *receivers: Receiver[ReceiverMessageT_co], name: str | None\n    ) -&gt; None:\n        \"\"\"Initialize this merger.\n\n        Args:\n            *receivers: The receivers to merge.\n            name: The name of the receiver. Used to create the string representation\n                of the receiver.\n        \"\"\"\n        self._receivers: dict[str, Receiver[ReceiverMessageT_co]] = {\n            str(id): recv for id, recv in enumerate(receivers)\n        }\n        self._name: str = name if name is not None else type(self).__name__\n        self._pending: set[asyncio.Task[Any]] = {\n            asyncio.create_task(anext(recv), name=name)\n            for name, recv in self._receivers.items()\n        }\n        self._results: deque[ReceiverMessageT_co] = deque(maxlen=len(self._receivers))\n\n    def __del__(self) -&gt; None:\n        \"\"\"Finalize this merger.\"\"\"\n        for task in self._pending:\n            if not task.done() and task.get_loop().is_running():\n                task.cancel()\n\n    async def stop(self) -&gt; None:\n        \"\"\"Stop this merger.\"\"\"\n        for task in self._pending:\n            task.cancel()\n        await asyncio.gather(*self._pending, return_exceptions=True)\n        self._pending = set()\n\n    async def ready(self) -&gt; bool:\n        \"\"\"Wait until the receiver is ready with a message or an error.\n\n        Once a call to `ready()` has finished, the message should be read with\n        a call to `consume()` (`receive()` or iterated over). The receiver will\n        remain ready (this method will return immediately) until it is\n        consumed.\n\n        Returns:\n            Whether the receiver is still active.\n        \"\"\"\n        # we use a while loop to continue to wait for new data, in case the\n        # previous `wait` completed because a channel was closed.\n        while True:\n            # if there are messages waiting to be consumed, return immediately.\n            if len(self._results) &gt; 0:\n                return True\n\n            # if there are no more pending receivers, we return immediately.\n            if len(self._pending) == 0:\n                return False\n\n            done, self._pending = await asyncio.wait(\n                self._pending, return_when=asyncio.FIRST_COMPLETED\n            )\n            for item in done:\n                name = item.get_name()\n                # if channel is closed, don't add a task for it again.\n                if isinstance(item.exception(), StopAsyncIteration):\n                    continue\n                result = item.result()\n                self._results.append(result)\n                self._pending.add(\n                    asyncio.create_task(anext(self._receivers[name]), name=name)\n                )\n\n    def consume(self) -&gt; ReceiverMessageT_co:\n        \"\"\"Return the latest message once `ready` is complete.\n\n        Returns:\n            The next message that was received.\n\n        Raises:\n            ReceiverStoppedError: If the receiver stopped producing messages.\n            ReceiverError: If there is some problem with the receiver.\n        \"\"\"\n        if not self._results and not self._pending:\n            raise ReceiverStoppedError(self)\n\n        assert self._results, \"`consume()` must be preceded by a call to `ready()`\"\n\n        return self._results.popleft()\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this receiver.\"\"\"\n        if len(self._receivers) &gt; 3:\n            receivers = [str(p) for p in itertools.islice(self._receivers.values(), 3)]\n            receivers.append(\"\u2026\")\n        else:\n            receivers = [str(p) for p in self._receivers.values()]\n        return f\"{self._name}:{','.join(receivers)}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this receiver.\"\"\"\n        return (\n            f\"{self._name}(\"\n            f\"{', '.join(f'{k}={v!r}' for k, v in self._receivers.items())})\"\n        )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; Self\n</code></pre> <p>Get an async iterator over the received messages.</p> RETURNS DESCRIPTION <code>Self</code> <p>This receiver, as it is already an async iterator.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def __aiter__(self) -&gt; Self:\n    \"\"\"Get an async iterator over the received messages.\n\n    Returns:\n        This receiver, as it is already an async iterator.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.__anext__","title":"__anext__  <code>async</code>","text":"<pre><code>__anext__() -&gt; ReceiverMessageT_co\n</code></pre> <p>Await the next message in the async iteration over received messages.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The next received message.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>If the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def __anext__(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Await the next message in the async iteration over received messages.\n\n    Returns:\n        The next received message.\n\n    Raises:\n        StopAsyncIteration: If the receiver stopped producing messages.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        await self.ready()\n        return self.consume()\n    except ReceiverStoppedError as exc:\n        raise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Finalize this merger.</p> Source code in <code>frequenz/channels/_merge.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Finalize this merger.\"\"\"\n    for task in self._pending:\n        if not task.done() and task.get_loop().is_running():\n            task.cancel()\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.__init__","title":"__init__","text":"<pre><code>__init__(\n    *receivers: Receiver[ReceiverMessageT_co],\n    name: str | None\n) -&gt; None\n</code></pre> <p>Initialize this merger.</p> PARAMETER  DESCRIPTION <code>*receivers</code> <p>The receivers to merge.</p> <p> TYPE: <code>Receiver[ReceiverMessageT_co]</code> DEFAULT: <code>()</code> </p> <code>name</code> <p>The name of the receiver. Used to create the string representation of the receiver.</p> <p> TYPE: <code>str | None</code> </p> Source code in <code>frequenz/channels/_merge.py</code> <pre><code>def __init__(\n    self, *receivers: Receiver[ReceiverMessageT_co], name: str | None\n) -&gt; None:\n    \"\"\"Initialize this merger.\n\n    Args:\n        *receivers: The receivers to merge.\n        name: The name of the receiver. Used to create the string representation\n            of the receiver.\n    \"\"\"\n    self._receivers: dict[str, Receiver[ReceiverMessageT_co]] = {\n        str(id): recv for id, recv in enumerate(receivers)\n    }\n    self._name: str = name if name is not None else type(self).__name__\n    self._pending: set[asyncio.Task[Any]] = {\n        asyncio.create_task(anext(recv), name=name)\n        for name, recv in self._receivers.items()\n    }\n    self._results: deque[ReceiverMessageT_co] = deque(maxlen=len(self._receivers))\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this receiver.</p> Source code in <code>frequenz/channels/_merge.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this receiver.\"\"\"\n    return (\n        f\"{self._name}(\"\n        f\"{', '.join(f'{k}={v!r}' for k, v in self._receivers.items())})\"\n    )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this receiver.</p> Source code in <code>frequenz/channels/_merge.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this receiver.\"\"\"\n    if len(self._receivers) &gt; 3:\n        receivers = [str(p) for p in itertools.islice(self._receivers.values(), 3)]\n        receivers.append(\"\u2026\")\n    else:\n        receivers = [str(p) for p in self._receivers.values()]\n    return f\"{self._name}:{','.join(receivers)}\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.consume","title":"consume","text":"<pre><code>consume() -&gt; ReceiverMessageT_co\n</code></pre> <p>Return the latest message once <code>ready</code> is complete.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The next message that was received.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_merge.py</code> <pre><code>def consume(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Return the latest message once `ready` is complete.\n\n    Returns:\n        The next message that was received.\n\n    Raises:\n        ReceiverStoppedError: If the receiver stopped producing messages.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    if not self._results and not self._pending:\n        raise ReceiverStoppedError(self)\n\n    assert self._results, \"`consume()` must be preceded by a call to `ready()`\"\n\n    return self._results.popleft()\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.map","title":"map","text":"<pre><code>map(\n    mapping_function: Callable[\n        [ReceiverMessageT_co], MappedMessageT_co\n    ]\n) -&gt; Receiver[MappedMessageT_co]\n</code></pre> <p>Apply a mapping function on the received message.</p> Tip <p>The returned receiver type won't have all the methods of the original receiver. If you need to access methods of the original receiver that are not part of the <code>Receiver</code> interface you should save a reference to the original receiver and use that instead.</p> PARAMETER  DESCRIPTION <code>mapping_function</code> <p>The function to be applied on incoming messages.</p> <p> TYPE: <code>Callable[[ReceiverMessageT_co], MappedMessageT_co]</code> </p> RETURNS DESCRIPTION <code>Receiver[MappedMessageT_co]</code> <p>A new receiver that applies the function on the received messages.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def map(\n    self, mapping_function: Callable[[ReceiverMessageT_co], MappedMessageT_co], /\n) -&gt; Receiver[MappedMessageT_co]:\n    \"\"\"Apply a mapping function on the received message.\n\n    Tip:\n        The returned receiver type won't have all the methods of the original\n        receiver. If you need to access methods of the original receiver that are\n        not part of the `Receiver` interface you should save a reference to the\n        original receiver and use that instead.\n\n    Args:\n        mapping_function: The function to be applied on incoming messages.\n\n    Returns:\n        A new receiver that applies the function on the received messages.\n    \"\"\"\n    return _Mapper(receiver=self, mapping_function=mapping_function)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.ready","title":"ready  <code>async</code>","text":"<pre><code>ready() -&gt; bool\n</code></pre> <p>Wait until the receiver is ready with a message or an error.</p> <p>Once a call to <code>ready()</code> has finished, the message should be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over). The receiver will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the receiver is still active.</p> Source code in <code>frequenz/channels/_merge.py</code> <pre><code>async def ready(self) -&gt; bool:\n    \"\"\"Wait until the receiver is ready with a message or an error.\n\n    Once a call to `ready()` has finished, the message should be read with\n    a call to `consume()` (`receive()` or iterated over). The receiver will\n    remain ready (this method will return immediately) until it is\n    consumed.\n\n    Returns:\n        Whether the receiver is still active.\n    \"\"\"\n    # we use a while loop to continue to wait for new data, in case the\n    # previous `wait` completed because a channel was closed.\n    while True:\n        # if there are messages waiting to be consumed, return immediately.\n        if len(self._results) &gt; 0:\n            return True\n\n        # if there are no more pending receivers, we return immediately.\n        if len(self._pending) == 0:\n            return False\n\n        done, self._pending = await asyncio.wait(\n            self._pending, return_when=asyncio.FIRST_COMPLETED\n        )\n        for item in done:\n            name = item.get_name()\n            # if channel is closed, don't add a task for it again.\n            if isinstance(item.exception(), StopAsyncIteration):\n                continue\n            result = item.result()\n            self._results.append(result)\n            self._pending.add(\n                asyncio.create_task(anext(self._receivers[name]), name=name)\n            )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.receive","title":"receive  <code>async</code>","text":"<pre><code>receive() -&gt; ReceiverMessageT_co\n</code></pre> <p>Receive a message.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If there is some problem with the receiver.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def receive(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Receive a message.\n\n    Returns:\n        The received message.\n\n    Raises:\n        ReceiverStoppedError: If there is some problem with the receiver.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        received = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\n    except StopAsyncIteration as exc:\n        # If we already had a cause and it was the receiver was stopped,\n        # then reuse that error, as StopAsyncIteration is just an artifact\n        # introduced by __anext__.\n        if (\n            isinstance(exc.__cause__, ReceiverStoppedError)\n            # pylint is not smart enough to figure out we checked above\n            # this is a ReceiverStoppedError and thus it does have\n            # a receiver member\n            and exc.__cause__.receiver is self  # pylint: disable=no-member\n        ):\n            raise exc.__cause__\n        raise ReceiverStoppedError(self) from exc\n    return received\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Merger.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop this merger.</p> Source code in <code>frequenz/channels/_merge.py</code> <pre><code>async def stop(self) -&gt; None:\n    \"\"\"Stop this merger.\"\"\"\n    for task in self._pending:\n        task.cancel()\n    await asyncio.gather(*self._pending, return_exceptions=True)\n    self._pending = set()\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver","title":"frequenz.channels.Receiver","text":"<p>             Bases: <code>ABC</code>, <code>Generic[ReceiverMessageT_co]</code></p> <p>An endpoint to receive messages.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>class Receiver(ABC, Generic[ReceiverMessageT_co]):\n    \"\"\"An endpoint to receive messages.\"\"\"\n\n    async def __anext__(self) -&gt; ReceiverMessageT_co:\n        \"\"\"Await the next message in the async iteration over received messages.\n\n        Returns:\n            The next received message.\n\n        Raises:\n            StopAsyncIteration: If the receiver stopped producing messages.\n            ReceiverError: If there is some problem with the receiver.\n        \"\"\"\n        try:\n            await self.ready()\n            return self.consume()\n        except ReceiverStoppedError as exc:\n            raise StopAsyncIteration() from exc\n\n    @abstractmethod\n    async def ready(self) -&gt; bool:\n        \"\"\"Wait until the receiver is ready with a message or an error.\n\n        Once a call to `ready()` has finished, the message should be read with\n        a call to `consume()` (`receive()` or iterated over). The receiver will\n        remain ready (this method will return immediately) until it is\n        consumed.\n\n        Returns:\n            Whether the receiver is still active.\n        \"\"\"\n\n    @abstractmethod\n    def consume(self) -&gt; ReceiverMessageT_co:\n        \"\"\"Return the latest message once `ready()` is complete.\n\n        `ready()` must be called before each call to `consume()`.\n\n        Returns:\n            The next message received.\n\n        Raises:\n            ReceiverStoppedError: If the receiver stopped producing messages.\n            ReceiverError: If there is some problem with the receiver.\n        \"\"\"\n\n    def __aiter__(self) -&gt; Self:\n        \"\"\"Get an async iterator over the received messages.\n\n        Returns:\n            This receiver, as it is already an async iterator.\n        \"\"\"\n        return self\n\n    async def receive(self) -&gt; ReceiverMessageT_co:\n        \"\"\"Receive a message.\n\n        Returns:\n            The received message.\n\n        Raises:\n            ReceiverStoppedError: If there is some problem with the receiver.\n            ReceiverError: If there is some problem with the receiver.\n        \"\"\"\n        try:\n            received = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\n        except StopAsyncIteration as exc:\n            # If we already had a cause and it was the receiver was stopped,\n            # then reuse that error, as StopAsyncIteration is just an artifact\n            # introduced by __anext__.\n            if (\n                isinstance(exc.__cause__, ReceiverStoppedError)\n                # pylint is not smart enough to figure out we checked above\n                # this is a ReceiverStoppedError and thus it does have\n                # a receiver member\n                and exc.__cause__.receiver is self  # pylint: disable=no-member\n            ):\n                raise exc.__cause__\n            raise ReceiverStoppedError(self) from exc\n        return received\n\n    def map(\n        self, mapping_function: Callable[[ReceiverMessageT_co], MappedMessageT_co], /\n    ) -&gt; Receiver[MappedMessageT_co]:\n        \"\"\"Apply a mapping function on the received message.\n\n        Tip:\n            The returned receiver type won't have all the methods of the original\n            receiver. If you need to access methods of the original receiver that are\n            not part of the `Receiver` interface you should save a reference to the\n            original receiver and use that instead.\n\n        Args:\n            mapping_function: The function to be applied on incoming messages.\n\n        Returns:\n            A new receiver that applies the function on the received messages.\n        \"\"\"\n        return _Mapper(receiver=self, mapping_function=mapping_function)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; Self\n</code></pre> <p>Get an async iterator over the received messages.</p> RETURNS DESCRIPTION <code>Self</code> <p>This receiver, as it is already an async iterator.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def __aiter__(self) -&gt; Self:\n    \"\"\"Get an async iterator over the received messages.\n\n    Returns:\n        This receiver, as it is already an async iterator.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.__anext__","title":"__anext__  <code>async</code>","text":"<pre><code>__anext__() -&gt; ReceiverMessageT_co\n</code></pre> <p>Await the next message in the async iteration over received messages.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The next received message.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>If the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def __anext__(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Await the next message in the async iteration over received messages.\n\n    Returns:\n        The next received message.\n\n    Raises:\n        StopAsyncIteration: If the receiver stopped producing messages.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        await self.ready()\n        return self.consume()\n    except ReceiverStoppedError as exc:\n        raise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.consume","title":"consume  <code>abstractmethod</code>","text":"<pre><code>consume() -&gt; ReceiverMessageT_co\n</code></pre> <p>Return the latest message once <code>ready()</code> is complete.</p> <p><code>ready()</code> must be called before each call to <code>consume()</code>.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The next message received.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>@abstractmethod\ndef consume(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Return the latest message once `ready()` is complete.\n\n    `ready()` must be called before each call to `consume()`.\n\n    Returns:\n        The next message received.\n\n    Raises:\n        ReceiverStoppedError: If the receiver stopped producing messages.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.map","title":"map","text":"<pre><code>map(\n    mapping_function: Callable[\n        [ReceiverMessageT_co], MappedMessageT_co\n    ]\n) -&gt; Receiver[MappedMessageT_co]\n</code></pre> <p>Apply a mapping function on the received message.</p> Tip <p>The returned receiver type won't have all the methods of the original receiver. If you need to access methods of the original receiver that are not part of the <code>Receiver</code> interface you should save a reference to the original receiver and use that instead.</p> PARAMETER  DESCRIPTION <code>mapping_function</code> <p>The function to be applied on incoming messages.</p> <p> TYPE: <code>Callable[[ReceiverMessageT_co], MappedMessageT_co]</code> </p> RETURNS DESCRIPTION <code>Receiver[MappedMessageT_co]</code> <p>A new receiver that applies the function on the received messages.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def map(\n    self, mapping_function: Callable[[ReceiverMessageT_co], MappedMessageT_co], /\n) -&gt; Receiver[MappedMessageT_co]:\n    \"\"\"Apply a mapping function on the received message.\n\n    Tip:\n        The returned receiver type won't have all the methods of the original\n        receiver. If you need to access methods of the original receiver that are\n        not part of the `Receiver` interface you should save a reference to the\n        original receiver and use that instead.\n\n    Args:\n        mapping_function: The function to be applied on incoming messages.\n\n    Returns:\n        A new receiver that applies the function on the received messages.\n    \"\"\"\n    return _Mapper(receiver=self, mapping_function=mapping_function)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.ready","title":"ready  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>ready() -&gt; bool\n</code></pre> <p>Wait until the receiver is ready with a message or an error.</p> <p>Once a call to <code>ready()</code> has finished, the message should be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over). The receiver will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the receiver is still active.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>@abstractmethod\nasync def ready(self) -&gt; bool:\n    \"\"\"Wait until the receiver is ready with a message or an error.\n\n    Once a call to `ready()` has finished, the message should be read with\n    a call to `consume()` (`receive()` or iterated over). The receiver will\n    remain ready (this method will return immediately) until it is\n    consumed.\n\n    Returns:\n        Whether the receiver is still active.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver.receive","title":"receive  <code>async</code>","text":"<pre><code>receive() -&gt; ReceiverMessageT_co\n</code></pre> <p>Receive a message.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If there is some problem with the receiver.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def receive(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Receive a message.\n\n    Returns:\n        The received message.\n\n    Raises:\n        ReceiverStoppedError: If there is some problem with the receiver.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        received = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\n    except StopAsyncIteration as exc:\n        # If we already had a cause and it was the receiver was stopped,\n        # then reuse that error, as StopAsyncIteration is just an artifact\n        # introduced by __anext__.\n        if (\n            isinstance(exc.__cause__, ReceiverStoppedError)\n            # pylint is not smart enough to figure out we checked above\n            # this is a ReceiverStoppedError and thus it does have\n            # a receiver member\n            and exc.__cause__.receiver is self  # pylint: disable=no-member\n        ):\n            raise exc.__cause__\n        raise ReceiverStoppedError(self) from exc\n    return received\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverError","title":"frequenz.channels.ReceiverError","text":"<p>             Bases: <code>Error</code>, <code>Generic[ReceiverMessageT_co]</code></p> <p>An error that originated in a Receiver.</p> <p>All exceptions generated by receivers inherit from this exception.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>class ReceiverError(Error, Generic[ReceiverMessageT_co]):\n    \"\"\"An error that originated in a [Receiver][frequenz.channels.Receiver].\n\n    All exceptions generated by receivers inherit from this exception.\n    \"\"\"\n\n    def __init__(self, message: str, receiver: Receiver[ReceiverMessageT_co]):\n        \"\"\"Initialize this error.\n\n        Args:\n            message: The error message.\n            receiver: The [Receiver][frequenz.channels.Receiver] where the\n                error happened.\n        \"\"\"\n        super().__init__(message)\n        self.receiver: Receiver[ReceiverMessageT_co] = receiver\n        \"\"\"The receiver where the error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverError.receiver","title":"receiver  <code>instance-attribute</code>","text":"<pre><code>receiver: Receiver[ReceiverMessageT_co] = receiver\n</code></pre> <p>The receiver where the error happened.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str, receiver: Receiver[ReceiverMessageT_co]\n)\n</code></pre> <p>Initialize this error.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p> <code>receiver</code> <p>The Receiver where the error happened.</p> <p> TYPE: <code>Receiver[ReceiverMessageT_co]</code> </p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def __init__(self, message: str, receiver: Receiver[ReceiverMessageT_co]):\n    \"\"\"Initialize this error.\n\n    Args:\n        message: The error message.\n        receiver: The [Receiver][frequenz.channels.Receiver] where the\n            error happened.\n    \"\"\"\n    super().__init__(message)\n    self.receiver: Receiver[ReceiverMessageT_co] = receiver\n    \"\"\"The receiver where the error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverStoppedError","title":"frequenz.channels.ReceiverStoppedError","text":"<p>             Bases: <code>ReceiverError[ReceiverMessageT_co]</code></p> <p>A stopped <code>Receiver</code> was used.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>class ReceiverStoppedError(ReceiverError[ReceiverMessageT_co]):\n    \"\"\"A stopped [`Receiver`][frequenz.channels.Receiver] was used.\"\"\"\n\n    def __init__(self, receiver: Receiver[ReceiverMessageT_co]):\n        \"\"\"Initialize this error.\n\n        Args:\n            receiver: The [Receiver][frequenz.channels.Receiver] where the\n                error happened.\n        \"\"\"\n        super().__init__(f\"Receiver {receiver} was stopped\", receiver)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverStoppedError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverStoppedError.receiver","title":"receiver  <code>instance-attribute</code>","text":"<pre><code>receiver: Receiver[ReceiverMessageT_co] = receiver\n</code></pre> <p>The receiver where the error happened.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverStoppedError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.ReceiverStoppedError.__init__","title":"__init__","text":"<pre><code>__init__(receiver: Receiver[ReceiverMessageT_co])\n</code></pre> <p>Initialize this error.</p> PARAMETER  DESCRIPTION <code>receiver</code> <p>The Receiver where the error happened.</p> <p> TYPE: <code>Receiver[ReceiverMessageT_co]</code> </p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def __init__(self, receiver: Receiver[ReceiverMessageT_co]):\n    \"\"\"Initialize this error.\n\n    Args:\n        receiver: The [Receiver][frequenz.channels.Receiver] where the\n            error happened.\n    \"\"\"\n    super().__init__(f\"Receiver {receiver} was stopped\", receiver)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.SelectError","title":"frequenz.channels.SelectError","text":"<p>             Bases: <code>Error</code></p> <p>An error that happened during a <code>select()</code> operation.</p> <p>This exception is raised when a <code>select()</code> iteration fails.  It is raised as a single exception when one receiver fails during normal operation (while calling <code>ready()</code> for example).  It is raised as a group exception (<code>BaseExceptionGroup</code>) when a <code>select</code> loop is cleaning up after it's done.</p> Source code in <code>frequenz/channels/_select.py</code> <pre><code>class SelectError(Error):\n    \"\"\"An error that happened during a [`select()`][frequenz.channels.select] operation.\n\n    This exception is raised when a `select()` iteration fails.  It is raised as\n    a single exception when one receiver fails during normal operation (while calling\n    `ready()` for example).  It is raised as a group exception\n    ([`BaseExceptionGroup`][]) when a `select` loop is cleaning up after it's done.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Selected","title":"frequenz.channels.Selected","text":"<p>             Bases: <code>Generic[ReceiverMessageT_co]</code></p> <p>A result of a <code>select()</code> iteration.</p> <p>The selected receiver is consumed immediately and the received message is stored in the instance, unless there was an exception while receiving the message, in which case the exception is stored instead.</p> <p><code>Selected</code> instances should be used in conjunction with the <code>selected_from()</code> function to determine which receiver was selected.</p> <p>Please see <code>select()</code> for an example.</p> Source code in <code>frequenz/channels/_select.py</code> <pre><code>class Selected(Generic[ReceiverMessageT_co]):\n    \"\"\"A result of a [`select()`][frequenz.channels.select] iteration.\n\n    The selected receiver is consumed immediately and the received message is stored in\n    the instance, unless there was an exception while receiving the message, in which\n    case the exception is stored instead.\n\n    `Selected` instances should be used in conjunction with the\n    [`selected_from()`][frequenz.channels.selected_from] function to determine\n    which receiver was selected.\n\n    Please see [`select()`][frequenz.channels.select] for an example.\n    \"\"\"\n\n    def __init__(self, receiver: Receiver[ReceiverMessageT_co], /) -&gt; None:\n        \"\"\"Initialize this selected result.\n\n        The receiver is consumed immediately when creating the instance and the received\n        message is stored in the instance for later use as\n        [`message`][frequenz.channels.Selected.message].  If there was an exception\n        while receiving the message, then the exception is stored in the instance\n        instead (as [`exception`][frequenz.channels.Selected.exception]).\n\n        Args:\n            receiver: The receiver that was selected.\n        \"\"\"\n        self._recv: Receiver[ReceiverMessageT_co] = receiver\n        \"\"\"The receiver that was selected.\"\"\"\n\n        self._message: ReceiverMessageT_co | _EmptyResult = _EmptyResult()\n        \"\"\"The message that was received.\n\n        If there was an exception while receiving the message, then this will be `None`.\n        \"\"\"\n        self._exception: Exception | None = None\n        \"\"\"The exception that was raised while receiving the message (if any).\"\"\"\n\n        try:\n            self._message = receiver.consume()\n        except Exception as exc:  # pylint: disable=broad-except\n            self._exception = exc\n\n        self._handled: bool = False\n        \"\"\"Flag to indicate if this selected has been handled in the if-chain.\"\"\"\n\n    @property\n    def message(self) -&gt; ReceiverMessageT_co:\n        \"\"\"The message that was received, if any.\n\n        Returns:\n            The message that was received.\n\n        Raises:\n            Exception: If there was an exception while receiving the message. Normally\n                this should be an [`frequenz.channels.Error`][frequenz.channels.Error]\n                instance, but catches all exceptions in case some receivers can raise\n                anything else.\n        \"\"\"\n        if self._exception is not None:\n            raise self._exception\n        assert not isinstance(self._message, _EmptyResult)\n        return self._message\n\n    @property\n    def exception(self) -&gt; Exception | None:\n        \"\"\"The exception that was raised while receiving the message (if any).\n\n        Returns:\n            The exception that was raised while receiving the message (if any).\n        \"\"\"\n        return self._exception\n\n    @property\n    def was_stopped(self) -&gt; bool:\n        \"\"\"Whether the selected receiver was stopped while receiving a message.\"\"\"\n        return isinstance(self._exception, ReceiverStoppedError)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this selected receiver.\"\"\"\n        return (\n            f\"{type(self).__name__}({self._recv}) -&gt; \"\n            f\"{self._exception or self._message})\"\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string with the internal representation of this instance.\"\"\"\n        return (\n            f\"{type(self).__name__}({self._recv=}, {self._message=}, \"\n            f\"{self._exception=}, {self._handled=})\"\n        )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Selected-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Selected.exception","title":"exception  <code>property</code>","text":"<pre><code>exception: Exception | None\n</code></pre> <p>The exception that was raised while receiving the message (if any).</p> RETURNS DESCRIPTION <code>Exception | None</code> <p>The exception that was raised while receiving the message (if any).</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Selected.message","title":"message  <code>property</code>","text":"<pre><code>message: ReceiverMessageT_co\n</code></pre> <p>The message that was received, if any.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The message that was received.</p> RAISES DESCRIPTION <code>Exception</code> <p>If there was an exception while receiving the message. Normally this should be an <code>frequenz.channels.Error</code> instance, but catches all exceptions in case some receivers can raise anything else.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Selected.was_stopped","title":"was_stopped  <code>property</code>","text":"<pre><code>was_stopped: bool\n</code></pre> <p>Whether the selected receiver was stopped while receiving a message.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.Selected-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Selected.__init__","title":"__init__","text":"<pre><code>__init__(receiver: Receiver[ReceiverMessageT_co]) -&gt; None\n</code></pre> <p>Initialize this selected result.</p> <p>The receiver is consumed immediately when creating the instance and the received message is stored in the instance for later use as <code>message</code>.  If there was an exception while receiving the message, then the exception is stored in the instance instead (as <code>exception</code>).</p> PARAMETER  DESCRIPTION <code>receiver</code> <p>The receiver that was selected.</p> <p> TYPE: <code>Receiver[ReceiverMessageT_co]</code> </p> Source code in <code>frequenz/channels/_select.py</code> <pre><code>def __init__(self, receiver: Receiver[ReceiverMessageT_co], /) -&gt; None:\n    \"\"\"Initialize this selected result.\n\n    The receiver is consumed immediately when creating the instance and the received\n    message is stored in the instance for later use as\n    [`message`][frequenz.channels.Selected.message].  If there was an exception\n    while receiving the message, then the exception is stored in the instance\n    instead (as [`exception`][frequenz.channels.Selected.exception]).\n\n    Args:\n        receiver: The receiver that was selected.\n    \"\"\"\n    self._recv: Receiver[ReceiverMessageT_co] = receiver\n    \"\"\"The receiver that was selected.\"\"\"\n\n    self._message: ReceiverMessageT_co | _EmptyResult = _EmptyResult()\n    \"\"\"The message that was received.\n\n    If there was an exception while receiving the message, then this will be `None`.\n    \"\"\"\n    self._exception: Exception | None = None\n    \"\"\"The exception that was raised while receiving the message (if any).\"\"\"\n\n    try:\n        self._message = receiver.consume()\n    except Exception as exc:  # pylint: disable=broad-except\n        self._exception = exc\n\n    self._handled: bool = False\n    \"\"\"Flag to indicate if this selected has been handled in the if-chain.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Selected.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string with the internal representation of this instance.</p> Source code in <code>frequenz/channels/_select.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string with the internal representation of this instance.\"\"\"\n    return (\n        f\"{type(self).__name__}({self._recv=}, {self._message=}, \"\n        f\"{self._exception=}, {self._handled=})\"\n    )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Selected.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this selected receiver.</p> Source code in <code>frequenz/channels/_select.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this selected receiver.\"\"\"\n    return (\n        f\"{type(self).__name__}({self._recv}) -&gt; \"\n        f\"{self._exception or self._message})\"\n    )\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Sender","title":"frequenz.channels.Sender","text":"<p>             Bases: <code>ABC</code>, <code>Generic[SenderMessageT_contra]</code></p> <p>An endpoint to sends messages.</p> Source code in <code>frequenz/channels/_sender.py</code> <pre><code>class Sender(ABC, Generic[SenderMessageT_contra]):\n    \"\"\"An endpoint to sends messages.\"\"\"\n\n    @abstractmethod\n    async def send(self, message: SenderMessageT_contra, /) -&gt; None:\n        \"\"\"Send a message.\n\n        Args:\n            message: The message to be sent.\n\n        Raises:\n            SenderError: If there was an error sending the message.\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.Sender-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.Sender.send","title":"send  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>send(message: SenderMessageT_contra) -&gt; None\n</code></pre> <p>Send a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be sent.</p> <p> TYPE: <code>SenderMessageT_contra</code> </p> RAISES DESCRIPTION <code>SenderError</code> <p>If there was an error sending the message.</p> Source code in <code>frequenz/channels/_sender.py</code> <pre><code>@abstractmethod\nasync def send(self, message: SenderMessageT_contra, /) -&gt; None:\n    \"\"\"Send a message.\n\n    Args:\n        message: The message to be sent.\n\n    Raises:\n        SenderError: If there was an error sending the message.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.SenderError","title":"frequenz.channels.SenderError","text":"<p>             Bases: <code>Error</code>, <code>Generic[SenderMessageT_co]</code></p> <p>An error that originated in a Sender.</p> <p>All exceptions generated by senders inherit from this exception.</p> Source code in <code>frequenz/channels/_sender.py</code> <pre><code>class SenderError(Error, Generic[SenderMessageT_co]):\n    \"\"\"An error that originated in a [Sender][frequenz.channels.Sender].\n\n    All exceptions generated by senders inherit from this exception.\n    \"\"\"\n\n    def __init__(self, message: str, sender: Sender[SenderMessageT_co]):\n        \"\"\"Initialize this error.\n\n        Args:\n            message: The error message.\n            sender: The [Sender][frequenz.channels.Sender] where the error\n                happened.\n        \"\"\"\n        super().__init__(message)\n        self.sender: Sender[SenderMessageT_co] = sender\n        \"\"\"The sender where the error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.SenderError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.SenderError.sender","title":"sender  <code>instance-attribute</code>","text":"<pre><code>sender: Sender[SenderMessageT_co] = sender\n</code></pre> <p>The sender where the error happened.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.SenderError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.SenderError.__init__","title":"__init__","text":"<pre><code>__init__(message: str, sender: Sender[SenderMessageT_co])\n</code></pre> <p>Initialize this error.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The error message.</p> <p> TYPE: <code>str</code> </p> <code>sender</code> <p>The Sender where the error happened.</p> <p> TYPE: <code>Sender[SenderMessageT_co]</code> </p> Source code in <code>frequenz/channels/_sender.py</code> <pre><code>def __init__(self, message: str, sender: Sender[SenderMessageT_co]):\n    \"\"\"Initialize this error.\n\n    Args:\n        message: The error message.\n        sender: The [Sender][frequenz.channels.Sender] where the error\n            happened.\n    \"\"\"\n    super().__init__(message)\n    self.sender: Sender[SenderMessageT_co] = sender\n    \"\"\"The sender where the error happened.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.UnhandledSelectedError","title":"frequenz.channels.UnhandledSelectedError","text":"<p>             Bases: <code>SelectError</code>, <code>Generic[ReceiverMessageT_co]</code></p> <p>A receiver was not handled in a <code>select()</code> iteration.</p> <p>This exception is raised when a <code>select()</code> iteration finishes without a call to <code>selected_from()</code> for the selected receiver.</p> Source code in <code>frequenz/channels/_select.py</code> <pre><code>class UnhandledSelectedError(SelectError, Generic[ReceiverMessageT_co]):\n    \"\"\"A receiver was not handled in a [`select()`][frequenz.channels.select] iteration.\n\n    This exception is raised when a [`select()`][frequenz.channels.select] iteration\n    finishes without a call to [`selected_from()`][frequenz.channels.selected_from] for\n    the selected receiver.\n    \"\"\"\n\n    def __init__(self, selected: Selected[ReceiverMessageT_co]) -&gt; None:\n        \"\"\"Initialize this error.\n\n        Args:\n            selected: The selected receiver that was not handled.\n        \"\"\"\n        recv = selected._recv  # pylint: disable=protected-access\n        super().__init__(f\"Selected receiver {recv} was not handled in the if-chain\")\n        self.selected: Selected[ReceiverMessageT_co] = selected\n        \"\"\"The selected receiver that was not handled.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.UnhandledSelectedError-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.UnhandledSelectedError.selected","title":"selected  <code>instance-attribute</code>","text":"<pre><code>selected: Selected[ReceiverMessageT_co] = selected\n</code></pre> <p>The selected receiver that was not handled.</p>"},{"location":"reference/frequenz/channels/#frequenz.channels.UnhandledSelectedError-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.UnhandledSelectedError.__init__","title":"__init__","text":"<pre><code>__init__(selected: Selected[ReceiverMessageT_co]) -&gt; None\n</code></pre> <p>Initialize this error.</p> PARAMETER  DESCRIPTION <code>selected</code> <p>The selected receiver that was not handled.</p> <p> TYPE: <code>Selected[ReceiverMessageT_co]</code> </p> Source code in <code>frequenz/channels/_select.py</code> <pre><code>def __init__(self, selected: Selected[ReceiverMessageT_co]) -&gt; None:\n    \"\"\"Initialize this error.\n\n    Args:\n        selected: The selected receiver that was not handled.\n    \"\"\"\n    recv = selected._recv  # pylint: disable=protected-access\n    super().__init__(f\"Selected receiver {recv} was not handled in the if-chain\")\n    self.selected: Selected[ReceiverMessageT_co] = selected\n    \"\"\"The selected receiver that was not handled.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/#frequenz.channels.merge","title":"frequenz.channels.merge","text":"<pre><code>merge(\n    *receivers: Receiver[ReceiverMessageT_co],\n) -&gt; Merger[ReceiverMessageT_co]\n</code></pre> <p>Merge messages coming from multiple receivers into a single stream.</p> Example <p>For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream like this:</p> <pre><code>from frequenz.channels import Broadcast\n\nchannel1 = Broadcast[int](name=\"input-channel-1\")\nchannel2 = Broadcast[int](name=\"input-channel-2\")\nreceiver1 = channel1.new_receiver()\nreceiver2 = channel2.new_receiver()\n\nasync for message in merge(receiver1, receiver2):\n    print(f\"received {message}\")\n</code></pre> PARAMETER  DESCRIPTION <code>*receivers</code> <p>The receivers to merge.</p> <p> TYPE: <code>Receiver[ReceiverMessageT_co]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Merger[ReceiverMessageT_co]</code> <p>A receiver that merges the messages coming from multiple receivers into a single stream.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no receivers are provided.</p> Source code in <code>frequenz/channels/_merge.py</code> <pre><code>def merge(*receivers: Receiver[ReceiverMessageT_co]) -&gt; Merger[ReceiverMessageT_co]:\n    \"\"\"Merge messages coming from multiple receivers into a single stream.\n\n    Example:\n        For example, if there are two channel receivers with the same type,\n        they can be awaited together, and their results merged into a single\n        stream like this:\n\n        ```python\n        from frequenz.channels import Broadcast\n\n        channel1 = Broadcast[int](name=\"input-channel-1\")\n        channel2 = Broadcast[int](name=\"input-channel-2\")\n        receiver1 = channel1.new_receiver()\n        receiver2 = channel2.new_receiver()\n\n        async for message in merge(receiver1, receiver2):\n            print(f\"received {message}\")\n        ```\n\n    Args:\n        *receivers: The receivers to merge.\n\n    Returns:\n        A receiver that merges the messages coming from multiple receivers into a\n            single stream.\n\n    Raises:\n        ValueError: If no receivers are provided.\n    \"\"\"\n    if not receivers:\n        raise ValueError(\"At least one receiver must be provided\")\n\n    return Merger(*receivers, name=\"merge\")\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.select","title":"frequenz.channels.select  <code>async</code>","text":"<pre><code>select(\n    *receivers: Receiver[Any],\n) -&gt; AsyncIterator[Selected[Any]]\n</code></pre> <p>Iterate over the messages of all receivers as they receive new messages.</p> <p>This function is used to iterate over the messages of all receivers as they receive new messages.  It is used in conjunction with the <code>Selected</code> class and the <code>selected_from()</code> function to determine which function to determine which receiver was selected in a select operation.</p> <p>An exhaustiveness check is performed at runtime to make sure all selected receivers are handled in the if-chain, so you should call <code>selected_from()</code> with all the receivers passed to <code>select()</code> inside the select loop, even if you plan to ignore a message, to signal <code>select()</code> that you are purposefully ignoring the message.</p> Note <p>The <code>select()</code> function is intended to be used in cases where the set of receivers is static and known beforehand.  If you need to dynamically add/remove receivers from a select loop, there are a few alternatives.  Depending on your use case, one or the other could work better for you:</p> <ul> <li>Use <code>merge()</code>: this is useful when you have an   unknown number of receivers of the same type that can be handled as a group.</li> <li>Use tasks to manage each receiver individually: this is better if there are no   relationships between the receivers.</li> <li>Break the <code>select()</code> loop and start a new one with the new set of receivers   (this should be the last resort, as it has some performance implications    because the loop needs to be restarted).</li> </ul> Example <pre><code>import datetime\nfrom typing import assert_never\n\nfrom frequenz.channels import ReceiverStoppedError, select, selected_from\nfrom frequenz.channels.timer import SkipMissedAndDrift, Timer, TriggerAllMissed\n\ntimer1 = Timer(datetime.timedelta(seconds=1), TriggerAllMissed())\ntimer2 = Timer(datetime.timedelta(seconds=0.5), SkipMissedAndDrift())\n\nasync for selected in select(timer1, timer2):\n    if selected_from(selected, timer1):\n        # Beware: `selected.message` might raise an exception, you can always\n        # check for exceptions with `selected.exception` first or use\n        # a try-except block. You can also quickly check if the receiver was\n        # stopped and let any other unexpected exceptions bubble up.\n        if selected.was_stopped:\n            print(\"timer1 was stopped\")\n            continue\n        print(f\"timer1: now={datetime.datetime.now()} drift={selected.message}\")\n        timer2.stop()\n    elif selected_from(selected, timer2):\n        # Explicitly handling of exceptions\n        match selected.exception:\n            case ReceiverStoppedError():\n                print(\"timer2 was stopped\")\n            case Exception() as exception:\n                print(f\"timer2: exception={exception}\")\n            case None:\n                # All good, no exception, we can use `selected.message` safely\n                print(f\"timer2: now={datetime.datetime.now()} drift={selected.message}\")\n            case _ as unhanded:\n                assert_never(unhanded)\n    else:\n        # This is not necessary, as select() will check for exhaustiveness, but\n        # it is good practice to have it in case you forgot to handle a new\n        # receiver added to `select()` at a later point in time.\n        assert False\n</code></pre> PARAMETER  DESCRIPTION <code>*receivers</code> <p>The receivers to select from.</p> <p> TYPE: <code>Receiver[Any]</code> DEFAULT: <code>()</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[Selected[Any]]</code> <p>The currently selected item.</p> RAISES DESCRIPTION <code>UnhandledSelectedError</code> <p>If a selected receiver was not handled in the if-chain.</p> <code>BaseExceptionGroup</code> <p>If there is an error while finishing the select operation and receivers fail while cleaning up.</p> <code>SelectError</code> <p>If there is an error while selecting receivers during normal operation.  For example if a receiver raises an exception in the <code>ready()</code> method.  Normal errors while receiving messages are not raised, but reported via the <code>Selected</code> instance.</p> Source code in <code>frequenz/channels/_select.py</code> <pre><code>async def select(*receivers: Receiver[Any]) -&gt; AsyncIterator[Selected[Any]]:\n    \"\"\"Iterate over the messages of all receivers as they receive new messages.\n\n    This function is used to iterate over the messages of all receivers as they receive\n    new messages.  It is used in conjunction with the\n    [`Selected`][frequenz.channels.Selected] class and the\n    [`selected_from()`][frequenz.channels.selected_from] function to determine\n    which function to determine which receiver was selected in a select operation.\n\n    An exhaustiveness check is performed at runtime to make sure all selected receivers\n    are handled in the if-chain, so you should call `selected_from()` with all the\n    receivers passed to `select()` inside the select loop, even if you plan to ignore\n    a message, to signal `select()` that you are purposefully ignoring the message.\n\n    Note:\n        The `select()` function is intended to be used in cases where the set of\n        receivers is static and known beforehand.  If you need to dynamically add/remove\n        receivers from a select loop, there are a few alternatives.  Depending on your\n        use case, one or the other could work better for you:\n\n        * Use [`merge()`][frequenz.channels.merge]: this is useful when you have an\n          unknown number of receivers of the same type that can be handled as a group.\n        * Use tasks to manage each receiver individually: this is better if there are no\n          relationships between the receivers.\n        * Break the `select()` loop and start a new one with the new set of receivers\n          (this should be the last resort, as it has some performance implications\n           because the loop needs to be restarted).\n\n    Example:\n        ```python\n        import datetime\n        from typing import assert_never\n\n        from frequenz.channels import ReceiverStoppedError, select, selected_from\n        from frequenz.channels.timer import SkipMissedAndDrift, Timer, TriggerAllMissed\n\n        timer1 = Timer(datetime.timedelta(seconds=1), TriggerAllMissed())\n        timer2 = Timer(datetime.timedelta(seconds=0.5), SkipMissedAndDrift())\n\n        async for selected in select(timer1, timer2):\n            if selected_from(selected, timer1):\n                # Beware: `selected.message` might raise an exception, you can always\n                # check for exceptions with `selected.exception` first or use\n                # a try-except block. You can also quickly check if the receiver was\n                # stopped and let any other unexpected exceptions bubble up.\n                if selected.was_stopped:\n                    print(\"timer1 was stopped\")\n                    continue\n                print(f\"timer1: now={datetime.datetime.now()} drift={selected.message}\")\n                timer2.stop()\n            elif selected_from(selected, timer2):\n                # Explicitly handling of exceptions\n                match selected.exception:\n                    case ReceiverStoppedError():\n                        print(\"timer2 was stopped\")\n                    case Exception() as exception:\n                        print(f\"timer2: exception={exception}\")\n                    case None:\n                        # All good, no exception, we can use `selected.message` safely\n                        print(f\"timer2: now={datetime.datetime.now()} drift={selected.message}\")\n                    case _ as unhanded:\n                        assert_never(unhanded)\n            else:\n                # This is not necessary, as select() will check for exhaustiveness, but\n                # it is good practice to have it in case you forgot to handle a new\n                # receiver added to `select()` at a later point in time.\n                assert False\n        ```\n\n    Args:\n        *receivers: The receivers to select from.\n\n    Yields:\n        The currently selected item.\n\n    Raises:\n        UnhandledSelectedError: If a selected receiver was not handled in the if-chain.\n        BaseExceptionGroup: If there is an error while finishing the select operation\n            and receivers fail while cleaning up.\n        SelectError: If there is an error while selecting receivers during normal\n            operation.  For example if a receiver raises an exception in the `ready()`\n            method.  Normal errors while receiving messages are not raised, but reported\n            via the `Selected` instance.\n    \"\"\"\n    receivers_map: dict[str, Receiver[Any]] = {str(hash(r)): r for r in receivers}\n    pending: set[asyncio.Task[bool]] = set()\n\n    try:\n        for name, recv in receivers_map.items():\n            pending.add(asyncio.create_task(recv.ready(), name=name))\n\n        while pending:\n            done, pending = await asyncio.wait(\n                pending, return_when=asyncio.FIRST_COMPLETED\n            )\n\n            for task in done:\n                receiver_active: bool = True\n                name = task.get_name()\n                recv = receivers_map[name]\n                if exception := task.exception():\n                    match exception:\n                        case asyncio.CancelledError():\n                            # If the receiver was cancelled, then it means we want to\n                            # exit the select loop, so we handle the receiver but we\n                            # don't add it back to the pending list.\n                            receiver_active = False\n                        case _ as exc:\n                            raise SelectError(f\"Error while selecting {recv}\") from exc\n\n                selected = Selected(recv)\n                yield selected\n                if not selected._handled:  # pylint: disable=protected-access\n                    raise UnhandledSelectedError(selected)\n\n                receiver_active = task.result()\n                if not receiver_active:\n                    continue\n\n                # Add back the receiver to the pending list\n                name = task.get_name()\n                recv = receivers_map[name]\n                pending.add(asyncio.create_task(recv.ready(), name=name))\n    finally:\n        await _stop_pending_tasks(pending)\n</code></pre>"},{"location":"reference/frequenz/channels/#frequenz.channels.selected_from","title":"frequenz.channels.selected_from","text":"<pre><code>selected_from(\n    selected: Selected[Any],\n    receiver: Receiver[ReceiverMessageT_co],\n) -&gt; TypeGuard[Selected[ReceiverMessageT_co]]\n</code></pre> <p>Check whether the given receiver was selected by <code>select()</code>.</p> <p>This function is used in conjunction with the <code>Selected</code> class to determine which receiver was selected in <code>select()</code> iteration.</p> <p>It also works as a type guard to narrow the type of the <code>Selected</code> instance to the type of the receiver.</p> <p>Please see <code>select()</code> for an example.</p> PARAMETER  DESCRIPTION <code>selected</code> <p>The result of a <code>select()</code> iteration.</p> <p> TYPE: <code>Selected[Any]</code> </p> <code>receiver</code> <p>The receiver to check if it was the source of a select operation.</p> <p> TYPE: <code>Receiver[ReceiverMessageT_co]</code> </p> RETURNS DESCRIPTION <code>TypeGuard[Selected[ReceiverMessageT_co]]</code> <p>Whether the given receiver was selected.</p> Source code in <code>frequenz/channels/_select.py</code> <pre><code>def selected_from(\n    selected: Selected[Any], receiver: Receiver[ReceiverMessageT_co]\n) -&gt; TypeGuard[Selected[ReceiverMessageT_co]]:\n    \"\"\"Check whether the given receiver was selected by [`select()`][frequenz.channels.select].\n\n    This function is used in conjunction with the\n    [`Selected`][frequenz.channels.Selected] class to determine which receiver was\n    selected in `select()` iteration.\n\n    It also works as a [type guard][typing.TypeGuard] to narrow the type of the\n    `Selected` instance to the type of the receiver.\n\n    Please see [`select()`][frequenz.channels.select] for an example.\n\n    Args:\n        selected: The result of a `select()` iteration.\n        receiver: The receiver to check if it was the source of a select operation.\n\n    Returns:\n        Whether the given receiver was selected.\n    \"\"\"\n    if handled := selected._recv is receiver:  # pylint: disable=protected-access\n        selected._handled = True  # pylint: disable=protected-access\n    return handled\n</code></pre>"},{"location":"reference/frequenz/channels/event/","title":"event","text":""},{"location":"reference/frequenz/channels/event/#frequenz.channels.event","title":"frequenz.channels.event","text":"<p>A receiver that can be made ready directly.</p> <p>Tip</p> <p>Read the <code>Event</code> documentation for more information.</p> <p>This module contains the following:</p> <ul> <li><code>Event</code>:     A receiver that can be made ready directly.</li> </ul>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event-classes","title":"Classes","text":""},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event","title":"frequenz.channels.event.Event","text":"<p>             Bases: <code>Receiver[None]</code></p> <p>A receiver that can be made ready directly.</p>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event--usage","title":"Usage","text":"<p>There are cases where it is useful to be able to send a signal to a <code>select()</code> loop, for example, to stop a loop from outside the loop itself.</p> <p>To do that, you can use an <code>Event</code> receiver and call <code>set()</code> on it when you want to make it ready.</p>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event--stopping","title":"Stopping","text":"<p>The receiver will be re-activated (will keep blocking) after the current set event is received. To stop the receiver completely, you can call <code>stop()</code>.</p>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event--example","title":"Example","text":"Exit after printing the first 5 numbers <pre><code>import asyncio\n\nfrom frequenz.channels import Anycast, select, selected_from\nfrom frequenz.channels.event import Event\n\nchannel: Anycast[int] = Anycast(name=\"channel\")\nreceiver = channel.new_receiver()\nsender = channel.new_sender()\nstop_event = Event(name=\"stop\")\n\n\nasync def do_work() -&gt; None:\n    async for selected in select(receiver, stop_event):\n        if selected_from(selected, receiver):\n            print(selected.message)\n        elif selected_from(selected, stop_event):\n            print(\"Stop event triggered\")\n            stop_event.stop()\n            break\n\n\nasync def send_stuff() -&gt; None:\n    for i in range(10):\n        if stop_event.is_stopped:\n            break\n        await asyncio.sleep(1)\n        await sender.send(i)\n\n\nasync def main() -&gt; None:\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(do_work(), name=\"do_work\")\n        task_group.create_task(send_stuff(), name=\"send_stuff\")\n        await asyncio.sleep(5.5)\n        stop_event.set()\n\n\nasyncio.run(main())\n</code></pre> Source code in <code>frequenz/channels/event.py</code> <pre><code>class Event(_receiver.Receiver[None]):\n    \"\"\"A receiver that can be made ready directly.\n\n    # Usage\n\n    There are cases where it is useful to be able to send a signal to\n    a [`select()`][frequenz.channels.select] loop, for example, to stop a loop from\n    outside the loop itself.\n\n    To do that, you can use an [`Event`][frequenz.channels.event.Event] receiver and\n    call [`set()`][frequenz.channels.event.Event.set] on it when you want to make it\n    ready.\n\n    # Stopping\n\n    The receiver will be re-activated (will keep blocking) after the current set\n    event is received. To stop the receiver completely, you can call\n    [`stop()`][frequenz.channels.event.Event.stop].\n\n    # Example\n\n    Example: Exit after printing the first 5 numbers\n        ```python\n        import asyncio\n\n        from frequenz.channels import Anycast, select, selected_from\n        from frequenz.channels.event import Event\n\n        channel: Anycast[int] = Anycast(name=\"channel\")\n        receiver = channel.new_receiver()\n        sender = channel.new_sender()\n        stop_event = Event(name=\"stop\")\n\n\n        async def do_work() -&gt; None:\n            async for selected in select(receiver, stop_event):\n                if selected_from(selected, receiver):\n                    print(selected.message)\n                elif selected_from(selected, stop_event):\n                    print(\"Stop event triggered\")\n                    stop_event.stop()\n                    break\n\n\n        async def send_stuff() -&gt; None:\n            for i in range(10):\n                if stop_event.is_stopped:\n                    break\n                await asyncio.sleep(1)\n                await sender.send(i)\n\n\n        async def main() -&gt; None:\n            async with asyncio.TaskGroup() as task_group:\n                task_group.create_task(do_work(), name=\"do_work\")\n                task_group.create_task(send_stuff(), name=\"send_stuff\")\n                await asyncio.sleep(5.5)\n                stop_event.set()\n\n\n        asyncio.run(main())\n        ```\n    \"\"\"\n\n    def __init__(self, *, name: str | None = None) -&gt; None:\n        \"\"\"Initialize this event.\n\n        Args:\n            name: The name of the receiver.  If `None` an `id(self)`-based name will be\n                used. This is only for debugging purposes, it will be shown in the\n                string representation of the receiver.\n        \"\"\"\n        self._event: _asyncio.Event = _asyncio.Event()\n        \"\"\"The event that is set when the receiver is ready.\"\"\"\n\n        self._name: str = f\"{id(self):_}\" if name is None else name\n        \"\"\"The name of the receiver.\n\n        This is for debugging purposes, it will be shown in the string representation\n        of the receiver.\n        \"\"\"\n\n        self._is_set: bool = False\n        \"\"\"Whether the receiver is ready to be consumed.\n\n        This is used to differentiate between when the receiver was stopped (the event\n        is triggered too) but still there is an event to be consumed and when it was\n        stopped but was not explicitly set().\n        \"\"\"\n\n        self._is_stopped: bool = False\n        \"\"\"Whether the receiver is stopped.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The name of this receiver.\n\n        This is for debugging purposes, it will be shown in the string representation\n        of this receiver.\n        \"\"\"\n        return self._name\n\n    @property\n    def is_set(self) -&gt; bool:\n        \"\"\"Whether this receiver is set (ready).\"\"\"\n        return self._is_set\n\n    @property\n    def is_stopped(self) -&gt; bool:\n        \"\"\"Whether this receiver is stopped.\"\"\"\n        return self._is_stopped\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop this receiver.\"\"\"\n        self._is_stopped = True\n        self._event.set()\n\n    def set(self) -&gt; None:\n        \"\"\"Trigger the event (make the receiver ready).\"\"\"\n        self._is_set = True\n        self._event.set()\n\n    async def ready(self) -&gt; bool:\n        \"\"\"Wait until this receiver is ready.\n\n        Returns:\n            Whether this receiver is still running.\n        \"\"\"\n        if self._is_stopped:\n            return False\n        await self._event.wait()\n        return not self._is_stopped\n\n    def consume(self) -&gt; None:\n        \"\"\"Consume the event.\n\n        This makes this receiver wait again until the event is set again.\n\n        Raises:\n            ReceiverStoppedError: If this receiver is stopped.\n        \"\"\"\n        if not self._is_set and self._is_stopped:\n            raise _receiver.ReceiverStoppedError(self)\n\n        assert self._is_set, \"calls to `consume()` must be follow a call to `ready()`\"\n\n        self._is_set = False\n        self._event.clear()\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this event.\"\"\"\n        return f\"{type(self).__name__}({self._name!r})\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this event.\"\"\"\n        return (\n            f\"&lt;{type(self).__name__} name={self._name!r} is_set={self.is_set!r} \"\n            f\"is_stopped={self.is_stopped!r}&gt;\"\n        )\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.is_set","title":"is_set  <code>property</code>","text":"<pre><code>is_set: bool\n</code></pre> <p>Whether this receiver is set (ready).</p>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.is_stopped","title":"is_stopped  <code>property</code>","text":"<pre><code>is_stopped: bool\n</code></pre> <p>Whether this receiver is stopped.</p>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of this receiver.</p> <p>This is for debugging purposes, it will be shown in the string representation of this receiver.</p>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; Self\n</code></pre> <p>Get an async iterator over the received messages.</p> RETURNS DESCRIPTION <code>Self</code> <p>This receiver, as it is already an async iterator.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def __aiter__(self) -&gt; Self:\n    \"\"\"Get an async iterator over the received messages.\n\n    Returns:\n        This receiver, as it is already an async iterator.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.__anext__","title":"__anext__  <code>async</code>","text":"<pre><code>__anext__() -&gt; ReceiverMessageT_co\n</code></pre> <p>Await the next message in the async iteration over received messages.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The next received message.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>If the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def __anext__(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Await the next message in the async iteration over received messages.\n\n    Returns:\n        The next received message.\n\n    Raises:\n        StopAsyncIteration: If the receiver stopped producing messages.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        await self.ready()\n        return self.consume()\n    except ReceiverStoppedError as exc:\n        raise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.__init__","title":"__init__","text":"<pre><code>__init__(*, name: str | None = None) -&gt; None\n</code></pre> <p>Initialize this event.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of the receiver.  If <code>None</code> an <code>id(self)</code>-based name will be used. This is only for debugging purposes, it will be shown in the string representation of the receiver.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/channels/event.py</code> <pre><code>def __init__(self, *, name: str | None = None) -&gt; None:\n    \"\"\"Initialize this event.\n\n    Args:\n        name: The name of the receiver.  If `None` an `id(self)`-based name will be\n            used. This is only for debugging purposes, it will be shown in the\n            string representation of the receiver.\n    \"\"\"\n    self._event: _asyncio.Event = _asyncio.Event()\n    \"\"\"The event that is set when the receiver is ready.\"\"\"\n\n    self._name: str = f\"{id(self):_}\" if name is None else name\n    \"\"\"The name of the receiver.\n\n    This is for debugging purposes, it will be shown in the string representation\n    of the receiver.\n    \"\"\"\n\n    self._is_set: bool = False\n    \"\"\"Whether the receiver is ready to be consumed.\n\n    This is used to differentiate between when the receiver was stopped (the event\n    is triggered too) but still there is an event to be consumed and when it was\n    stopped but was not explicitly set().\n    \"\"\"\n\n    self._is_stopped: bool = False\n    \"\"\"Whether the receiver is stopped.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this event.</p> Source code in <code>frequenz/channels/event.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this event.\"\"\"\n    return (\n        f\"&lt;{type(self).__name__} name={self._name!r} is_set={self.is_set!r} \"\n        f\"is_stopped={self.is_stopped!r}&gt;\"\n    )\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this event.</p> Source code in <code>frequenz/channels/event.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this event.\"\"\"\n    return f\"{type(self).__name__}({self._name!r})\"\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.consume","title":"consume","text":"<pre><code>consume() -&gt; None\n</code></pre> <p>Consume the event.</p> <p>This makes this receiver wait again until the event is set again.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If this receiver is stopped.</p> Source code in <code>frequenz/channels/event.py</code> <pre><code>def consume(self) -&gt; None:\n    \"\"\"Consume the event.\n\n    This makes this receiver wait again until the event is set again.\n\n    Raises:\n        ReceiverStoppedError: If this receiver is stopped.\n    \"\"\"\n    if not self._is_set and self._is_stopped:\n        raise _receiver.ReceiverStoppedError(self)\n\n    assert self._is_set, \"calls to `consume()` must be follow a call to `ready()`\"\n\n    self._is_set = False\n    self._event.clear()\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.map","title":"map","text":"<pre><code>map(\n    mapping_function: Callable[\n        [ReceiverMessageT_co], MappedMessageT_co\n    ]\n) -&gt; Receiver[MappedMessageT_co]\n</code></pre> <p>Apply a mapping function on the received message.</p> Tip <p>The returned receiver type won't have all the methods of the original receiver. If you need to access methods of the original receiver that are not part of the <code>Receiver</code> interface you should save a reference to the original receiver and use that instead.</p> PARAMETER  DESCRIPTION <code>mapping_function</code> <p>The function to be applied on incoming messages.</p> <p> TYPE: <code>Callable[[ReceiverMessageT_co], MappedMessageT_co]</code> </p> RETURNS DESCRIPTION <code>Receiver[MappedMessageT_co]</code> <p>A new receiver that applies the function on the received messages.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def map(\n    self, mapping_function: Callable[[ReceiverMessageT_co], MappedMessageT_co], /\n) -&gt; Receiver[MappedMessageT_co]:\n    \"\"\"Apply a mapping function on the received message.\n\n    Tip:\n        The returned receiver type won't have all the methods of the original\n        receiver. If you need to access methods of the original receiver that are\n        not part of the `Receiver` interface you should save a reference to the\n        original receiver and use that instead.\n\n    Args:\n        mapping_function: The function to be applied on incoming messages.\n\n    Returns:\n        A new receiver that applies the function on the received messages.\n    \"\"\"\n    return _Mapper(receiver=self, mapping_function=mapping_function)\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.ready","title":"ready  <code>async</code>","text":"<pre><code>ready() -&gt; bool\n</code></pre> <p>Wait until this receiver is ready.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this receiver is still running.</p> Source code in <code>frequenz/channels/event.py</code> <pre><code>async def ready(self) -&gt; bool:\n    \"\"\"Wait until this receiver is ready.\n\n    Returns:\n        Whether this receiver is still running.\n    \"\"\"\n    if self._is_stopped:\n        return False\n    await self._event.wait()\n    return not self._is_stopped\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.receive","title":"receive  <code>async</code>","text":"<pre><code>receive() -&gt; ReceiverMessageT_co\n</code></pre> <p>Receive a message.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If there is some problem with the receiver.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def receive(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Receive a message.\n\n    Returns:\n        The received message.\n\n    Raises:\n        ReceiverStoppedError: If there is some problem with the receiver.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        received = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\n    except StopAsyncIteration as exc:\n        # If we already had a cause and it was the receiver was stopped,\n        # then reuse that error, as StopAsyncIteration is just an artifact\n        # introduced by __anext__.\n        if (\n            isinstance(exc.__cause__, ReceiverStoppedError)\n            # pylint is not smart enough to figure out we checked above\n            # this is a ReceiverStoppedError and thus it does have\n            # a receiver member\n            and exc.__cause__.receiver is self  # pylint: disable=no-member\n        ):\n            raise exc.__cause__\n        raise ReceiverStoppedError(self) from exc\n    return received\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.set","title":"set","text":"<pre><code>set() -&gt; None\n</code></pre> <p>Trigger the event (make the receiver ready).</p> Source code in <code>frequenz/channels/event.py</code> <pre><code>def set(self) -&gt; None:\n    \"\"\"Trigger the event (make the receiver ready).\"\"\"\n    self._is_set = True\n    self._event.set()\n</code></pre>"},{"location":"reference/frequenz/channels/event/#frequenz.channels.event.Event.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop this receiver.</p> Source code in <code>frequenz/channels/event.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop this receiver.\"\"\"\n    self._is_stopped = True\n    self._event.set()\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/","title":"file_watcher","text":""},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher","title":"frequenz.channels.file_watcher","text":"<p>A receiver for watching for new, modified or deleted files.</p> <p>Tip</p> <p>Read the <code>FileWatcher</code> documentation for more information.</p> <p>This module contains the following:</p> <ul> <li><code>FileWatcher</code>:     A receiver that watches for file events.</li> <li><code>Event</code>:     A file change event.</li> <li><code>EventType</code>:     The types of file events that can be observed.</li> </ul>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher-classes","title":"Classes","text":""},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.Event","title":"frequenz.channels.file_watcher.Event  <code>dataclass</code>","text":"<p>A file change event.</p> Source code in <code>frequenz/channels/file_watcher.py</code> <pre><code>@dataclass(frozen=True)\nclass Event:\n    \"\"\"A file change event.\"\"\"\n\n    type: EventType\n    \"\"\"The type of change that was observed.\"\"\"\n\n    path: pathlib.Path\n    \"\"\"The path where the change was observed.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.Event-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.Event.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: Path\n</code></pre> <p>The path where the change was observed.</p>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.Event.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: EventType\n</code></pre> <p>The type of change that was observed.</p>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.EventType","title":"frequenz.channels.file_watcher.EventType","text":"<p>             Bases: <code>Enum</code></p> <p>The types of file events that can be observed.</p> Source code in <code>frequenz/channels/file_watcher.py</code> <pre><code>class EventType(Enum):\n    \"\"\"The types of file events that can be observed.\"\"\"\n\n    CREATE = Change.added\n    \"\"\"The file was created.\"\"\"\n\n    MODIFY = Change.modified\n    \"\"\"The file was modified.\"\"\"\n\n    DELETE = Change.deleted\n    \"\"\"The file was deleted.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.EventType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.EventType.CREATE","title":"CREATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CREATE = added\n</code></pre> <p>The file was created.</p>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.EventType.DELETE","title":"DELETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DELETE = deleted\n</code></pre> <p>The file was deleted.</p>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.EventType.MODIFY","title":"MODIFY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODIFY = modified\n</code></pre> <p>The file was modified.</p>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher","title":"frequenz.channels.file_watcher.FileWatcher","text":"<p>             Bases: <code>Receiver[Event]</code></p> <p>A receiver that watches for file events.</p>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher--usage","title":"Usage","text":"<p>A <code>FileWatcher</code> receiver can be used to watch for changes in a set of files. It will generate an <code>Event</code> message every time a file is created, modified or deleted, depending on the type of events that it is configured to watch for.</p> <p>The event message contains the <code>type</code> of change that was observed and the <code>path</code> where the change was observed.</p>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher--event-types","title":"Event Types","text":"<p>The following event types are available:</p> <ul> <li><code>CREATE</code>:     The file was created.</li> <li><code>MODIFY</code>:     The file was modified.</li> <li><code>DELETE</code>:     The file was deleted.</li> </ul>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher--example","title":"Example","text":"Watch for changes and exit after the file is modified <pre><code>import asyncio\n\nfrom frequenz.channels.file_watcher import EventType, FileWatcher\n\nPATH = \"/tmp/test.txt\"\nfile_watcher = FileWatcher(paths=[PATH], event_types=[EventType.MODIFY])\n\n\nasync def update_file() -&gt; None:\n    await asyncio.sleep(1)\n    with open(PATH, \"w\", encoding=\"utf-8\") as file:\n        file.write(\"Hello, world!\")\n\n\nasync def main() -&gt; None:\n    # Create file\n    with open(PATH, \"w\", encoding=\"utf-8\") as file:\n        file.write(\"Hello, world!\")\n    async with asyncio.TaskGroup() as group:\n        group.create_task(update_file())\n        async for event in file_watcher:\n            print(f\"File {event.path}: {event.type.name}\")\n            break\n\n\nasyncio.run(main())\n</code></pre> Source code in <code>frequenz/channels/file_watcher.py</code> <pre><code>class FileWatcher(Receiver[Event]):\n    \"\"\"A receiver that watches for file events.\n\n    # Usage\n\n    A [`FileWatcher`][frequenz.channels.file_watcher.FileWatcher] receiver can be used\n    to watch for changes in a set of files. It will generate an\n    [`Event`][frequenz.channels.file_watcher.Event] message every time a file is\n    created, modified or deleted, depending on the type of events that it is configured\n    to watch for.\n\n    The [event][frequenz.channels.file_watcher.EventType] message contains the\n    [`type`][frequenz.channels.file_watcher.Event.type] of change that was observed and\n    the [`path`][frequenz.channels.file_watcher.Event.path] where the change was\n    observed.\n\n    # Event Types\n\n    The following event types are available:\n\n    * [`CREATE`][frequenz.channels.file_watcher.EventType.CREATE]:\n        {{docstring_summary(\"frequenz.channels.file_watcher.EventType.CREATE\")}}\n    * [`MODIFY`][frequenz.channels.file_watcher.EventType.MODIFY]:\n        {{docstring_summary(\"frequenz.channels.file_watcher.EventType.MODIFY\")}}\n    * [`DELETE`][frequenz.channels.file_watcher.EventType.DELETE]:\n        {{docstring_summary(\"frequenz.channels.file_watcher.EventType.DELETE\")}}\n\n    # Example\n\n    Example: Watch for changes and exit after the file is modified\n        ```python\n        import asyncio\n\n        from frequenz.channels.file_watcher import EventType, FileWatcher\n\n        PATH = \"/tmp/test.txt\"\n        file_watcher = FileWatcher(paths=[PATH], event_types=[EventType.MODIFY])\n\n\n        async def update_file() -&gt; None:\n            await asyncio.sleep(1)\n            with open(PATH, \"w\", encoding=\"utf-8\") as file:\n                file.write(\"Hello, world!\")\n\n\n        async def main() -&gt; None:\n            # Create file\n            with open(PATH, \"w\", encoding=\"utf-8\") as file:\n                file.write(\"Hello, world!\")\n            async with asyncio.TaskGroup() as group:\n                group.create_task(update_file())\n                async for event in file_watcher:\n                    print(f\"File {event.path}: {event.type.name}\")\n                    break\n\n\n        asyncio.run(main())\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        paths: list[pathlib.Path | str],\n        event_types: abc.Iterable[EventType] = frozenset(EventType),\n    ) -&gt; None:\n        \"\"\"Initialize this file watcher.\n\n        Args:\n            paths: The paths to watch for changes.\n            event_types: The types of events to watch for. Defaults to watch for\n                all event types.\n        \"\"\"\n        self.event_types: frozenset[EventType] = frozenset(event_types)\n        \"\"\"The types of events to watch for.\"\"\"\n\n        self._stop_event: asyncio.Event = asyncio.Event()\n        self._paths: list[pathlib.Path] = [\n            path if isinstance(path, pathlib.Path) else pathlib.Path(path)\n            for path in paths\n        ]\n        self._awatch: abc.AsyncGenerator[set[FileChange], None] = awatch(\n            *self._paths, stop_event=self._stop_event, watch_filter=self._filter_events\n        )\n        self._awatch_stopped_exc: Exception | None = None\n        self._changes: set[FileChange] = set()\n\n    def _filter_events(\n        self,\n        change: Change,\n        path: str,  # pylint: disable=unused-argument\n    ) -&gt; bool:\n        \"\"\"Filter events based on the event type and path.\n\n        Args:\n            change: The type of change to be notified.\n            path: The path of the file that changed.\n\n        Returns:\n            Whether the event should be notified.\n        \"\"\"\n        return change in [event_type.value for event_type in self.event_types]\n\n    def __del__(self) -&gt; None:\n        \"\"\"Finalize this file watcher.\"\"\"\n        # We need to set the stop event to make sure that the awatch background task\n        # is stopped.\n        self._stop_event.set()\n\n    async def ready(self) -&gt; bool:\n        \"\"\"Wait until the receiver is ready with a message or an error.\n\n        Once a call to `ready()` has finished, the message should be read with\n        a call to `consume()` (`receive()` or iterated over). The receiver will\n        remain ready (this method will return immediately) until it is\n        consumed.\n\n        Returns:\n            Whether the receiver is still active.\n        \"\"\"\n        # if there are messages waiting to be consumed, return immediately.\n        if self._changes:\n            return True\n\n        # if it was already stopped, return immediately.\n        if self._awatch_stopped_exc is not None:\n            return False\n\n        try:\n            self._changes = await anext(self._awatch)\n        except StopAsyncIteration as err:\n            self._awatch_stopped_exc = err\n\n        return True\n\n    def consume(self) -&gt; Event:\n        \"\"\"Return the latest event once `ready` is complete.\n\n        Returns:\n            The next event that was received.\n\n        Raises:\n            ReceiverStoppedError: If there is some problem with the receiver.\n        \"\"\"\n        if not self._changes and self._awatch_stopped_exc is not None:\n            raise ReceiverStoppedError(self) from self._awatch_stopped_exc\n\n        assert self._changes, \"`consume()` must be preceded by a call to `ready()`\"\n        # Tuple of (Change, path) returned by watchfiles\n        change, path_str = self._changes.pop()\n        return Event(type=EventType(change), path=pathlib.Path(path_str))\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this receiver.\"\"\"\n        if len(self._paths) &gt; 3:\n            paths = [str(p) for p in self._paths[:3]]\n            paths.append(\"\u2026\")\n        else:\n            paths = [str(p) for p in self._paths]\n        event_types = [event_type.name for event_type in self.event_types]\n        return f\"{type(self).__name__}:{','.join(event_types)}:{','.join(paths)}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this receiver.\"\"\"\n        return f\"{type(self).__name__}({self._paths!r}, {self.event_types!r})\"\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.event_types","title":"event_types  <code>instance-attribute</code>","text":"<pre><code>event_types: frozenset[EventType] = frozenset(event_types)\n</code></pre> <p>The types of events to watch for.</p>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; Self\n</code></pre> <p>Get an async iterator over the received messages.</p> RETURNS DESCRIPTION <code>Self</code> <p>This receiver, as it is already an async iterator.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def __aiter__(self) -&gt; Self:\n    \"\"\"Get an async iterator over the received messages.\n\n    Returns:\n        This receiver, as it is already an async iterator.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.__anext__","title":"__anext__  <code>async</code>","text":"<pre><code>__anext__() -&gt; ReceiverMessageT_co\n</code></pre> <p>Await the next message in the async iteration over received messages.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The next received message.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>If the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def __anext__(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Await the next message in the async iteration over received messages.\n\n    Returns:\n        The next received message.\n\n    Raises:\n        StopAsyncIteration: If the receiver stopped producing messages.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        await self.ready()\n        return self.consume()\n    except ReceiverStoppedError as exc:\n        raise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Finalize this file watcher.</p> Source code in <code>frequenz/channels/file_watcher.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Finalize this file watcher.\"\"\"\n    # We need to set the stop event to make sure that the awatch background task\n    # is stopped.\n    self._stop_event.set()\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.__init__","title":"__init__","text":"<pre><code>__init__(\n    paths: list[Path | str],\n    event_types: Iterable[EventType] = frozenset(EventType),\n) -&gt; None\n</code></pre> <p>Initialize this file watcher.</p> PARAMETER  DESCRIPTION <code>paths</code> <p>The paths to watch for changes.</p> <p> TYPE: <code>list[Path | str]</code> </p> <code>event_types</code> <p>The types of events to watch for. Defaults to watch for all event types.</p> <p> TYPE: <code>Iterable[EventType]</code> DEFAULT: <code>frozenset(EventType)</code> </p> Source code in <code>frequenz/channels/file_watcher.py</code> <pre><code>def __init__(\n    self,\n    paths: list[pathlib.Path | str],\n    event_types: abc.Iterable[EventType] = frozenset(EventType),\n) -&gt; None:\n    \"\"\"Initialize this file watcher.\n\n    Args:\n        paths: The paths to watch for changes.\n        event_types: The types of events to watch for. Defaults to watch for\n            all event types.\n    \"\"\"\n    self.event_types: frozenset[EventType] = frozenset(event_types)\n    \"\"\"The types of events to watch for.\"\"\"\n\n    self._stop_event: asyncio.Event = asyncio.Event()\n    self._paths: list[pathlib.Path] = [\n        path if isinstance(path, pathlib.Path) else pathlib.Path(path)\n        for path in paths\n    ]\n    self._awatch: abc.AsyncGenerator[set[FileChange], None] = awatch(\n        *self._paths, stop_event=self._stop_event, watch_filter=self._filter_events\n    )\n    self._awatch_stopped_exc: Exception | None = None\n    self._changes: set[FileChange] = set()\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this receiver.</p> Source code in <code>frequenz/channels/file_watcher.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this receiver.\"\"\"\n    return f\"{type(self).__name__}({self._paths!r}, {self.event_types!r})\"\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this receiver.</p> Source code in <code>frequenz/channels/file_watcher.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this receiver.\"\"\"\n    if len(self._paths) &gt; 3:\n        paths = [str(p) for p in self._paths[:3]]\n        paths.append(\"\u2026\")\n    else:\n        paths = [str(p) for p in self._paths]\n    event_types = [event_type.name for event_type in self.event_types]\n    return f\"{type(self).__name__}:{','.join(event_types)}:{','.join(paths)}\"\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.consume","title":"consume","text":"<pre><code>consume() -&gt; Event\n</code></pre> <p>Return the latest event once <code>ready</code> is complete.</p> RETURNS DESCRIPTION <code>Event</code> <p>The next event that was received.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/file_watcher.py</code> <pre><code>def consume(self) -&gt; Event:\n    \"\"\"Return the latest event once `ready` is complete.\n\n    Returns:\n        The next event that was received.\n\n    Raises:\n        ReceiverStoppedError: If there is some problem with the receiver.\n    \"\"\"\n    if not self._changes and self._awatch_stopped_exc is not None:\n        raise ReceiverStoppedError(self) from self._awatch_stopped_exc\n\n    assert self._changes, \"`consume()` must be preceded by a call to `ready()`\"\n    # Tuple of (Change, path) returned by watchfiles\n    change, path_str = self._changes.pop()\n    return Event(type=EventType(change), path=pathlib.Path(path_str))\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.map","title":"map","text":"<pre><code>map(\n    mapping_function: Callable[\n        [ReceiverMessageT_co], MappedMessageT_co\n    ]\n) -&gt; Receiver[MappedMessageT_co]\n</code></pre> <p>Apply a mapping function on the received message.</p> Tip <p>The returned receiver type won't have all the methods of the original receiver. If you need to access methods of the original receiver that are not part of the <code>Receiver</code> interface you should save a reference to the original receiver and use that instead.</p> PARAMETER  DESCRIPTION <code>mapping_function</code> <p>The function to be applied on incoming messages.</p> <p> TYPE: <code>Callable[[ReceiverMessageT_co], MappedMessageT_co]</code> </p> RETURNS DESCRIPTION <code>Receiver[MappedMessageT_co]</code> <p>A new receiver that applies the function on the received messages.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def map(\n    self, mapping_function: Callable[[ReceiverMessageT_co], MappedMessageT_co], /\n) -&gt; Receiver[MappedMessageT_co]:\n    \"\"\"Apply a mapping function on the received message.\n\n    Tip:\n        The returned receiver type won't have all the methods of the original\n        receiver. If you need to access methods of the original receiver that are\n        not part of the `Receiver` interface you should save a reference to the\n        original receiver and use that instead.\n\n    Args:\n        mapping_function: The function to be applied on incoming messages.\n\n    Returns:\n        A new receiver that applies the function on the received messages.\n    \"\"\"\n    return _Mapper(receiver=self, mapping_function=mapping_function)\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.ready","title":"ready  <code>async</code>","text":"<pre><code>ready() -&gt; bool\n</code></pre> <p>Wait until the receiver is ready with a message or an error.</p> <p>Once a call to <code>ready()</code> has finished, the message should be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over). The receiver will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the receiver is still active.</p> Source code in <code>frequenz/channels/file_watcher.py</code> <pre><code>async def ready(self) -&gt; bool:\n    \"\"\"Wait until the receiver is ready with a message or an error.\n\n    Once a call to `ready()` has finished, the message should be read with\n    a call to `consume()` (`receive()` or iterated over). The receiver will\n    remain ready (this method will return immediately) until it is\n    consumed.\n\n    Returns:\n        Whether the receiver is still active.\n    \"\"\"\n    # if there are messages waiting to be consumed, return immediately.\n    if self._changes:\n        return True\n\n    # if it was already stopped, return immediately.\n    if self._awatch_stopped_exc is not None:\n        return False\n\n    try:\n        self._changes = await anext(self._awatch)\n    except StopAsyncIteration as err:\n        self._awatch_stopped_exc = err\n\n    return True\n</code></pre>"},{"location":"reference/frequenz/channels/file_watcher/#frequenz.channels.file_watcher.FileWatcher.receive","title":"receive  <code>async</code>","text":"<pre><code>receive() -&gt; ReceiverMessageT_co\n</code></pre> <p>Receive a message.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If there is some problem with the receiver.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def receive(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Receive a message.\n\n    Returns:\n        The received message.\n\n    Raises:\n        ReceiverStoppedError: If there is some problem with the receiver.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        received = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\n    except StopAsyncIteration as exc:\n        # If we already had a cause and it was the receiver was stopped,\n        # then reuse that error, as StopAsyncIteration is just an artifact\n        # introduced by __anext__.\n        if (\n            isinstance(exc.__cause__, ReceiverStoppedError)\n            # pylint is not smart enough to figure out we checked above\n            # this is a ReceiverStoppedError and thus it does have\n            # a receiver member\n            and exc.__cause__.receiver is self  # pylint: disable=no-member\n        ):\n            raise exc.__cause__\n        raise ReceiverStoppedError(self) from exc\n    return received\n</code></pre>"},{"location":"reference/frequenz/channels/timer/","title":"timer","text":""},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer","title":"frequenz.channels.timer","text":"<p>A receiver that sends a message regularly.</p>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer--quick-start","title":"Quick Start","text":"Important <p>This quick start is provided to have a quick feeling of how to use this module, but it is extremely important to understand how timers behave when they are delayed.</p> <p>We recommend emphatically to read about missed ticks and drifting before using timers in production.</p> <p>If you need to do something as periodically as possible (avoiding drifts), you can use a <code>Timer</code> like this:</p> Periodic Timer Example <pre><code>import asyncio\nfrom datetime import datetime, timedelta\n\nfrom frequenz.channels.timer import Timer\n\n\nasync def main() -&gt; None:\n    async for drift in Timer(timedelta(seconds=1.0), TriggerAllMissed()):\n        print(f\"The timer has triggered at {datetime.now()} with a drift of {drift}\")\n\n\nasyncio.run(main())\n</code></pre> <p>This timer will tick as close as every second as possible, even if the loop is busy doing something else for a good amount of time. In extreme cases, if the loop was busy for a few seconds, the timer will trigger a few times in a row to catch up, one for every missed tick.</p> <p>If, instead, you need a timeout, for example to abort waiting for other receivers after a certain amount of time, you can use a <code>Timer</code> like this:</p> Timeout Example <pre><code>import asyncio\nfrom datetime import timedelta\n\nfrom frequenz.channels import Anycast, select, selected_from\nfrom frequenz.channels.timer import Timer\n\n\nasync def main() -&gt; None:\n    channel = Anycast[int](name=\"data-channel\")\n    data_receiver = channel.new_receiver()\n\n    timer = Timer(timedelta(seconds=1.0), SkipMissedAndDrift())\n\n    async for selected in select(data_receiver, timer):\n        if selected_from(selected, data_receiver):\n            print(f\"Received data: {selected.message}\")\n            timer.reset()\n        elif selected_from(selected, timer):\n            drift = selected.message\n            print(f\"No data received for {timer.interval + drift} seconds, giving up\")\n            break\n\n\nasyncio.run(main())\n</code></pre> <p>This timer will rearm itself automatically after it was triggered, so it will trigger again after the selected interval, no matter what the current drift was. So if the loop was busy for a few seconds, the timer will trigger immediately and then wait for another second before triggering again. The missed ticks are skipped.</p>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer--missed-ticks-and-drifting","title":"Missed Ticks And Drifting","text":"<p>A <code>Timer</code> can be used to send a messages at regular time intervals, but there is one fundamental issue with timers in the asyncio world: the event loop could give control to another task at any time, and that task can take a long time to finish, making the time it takes the next timer message to be received longer than the desired interval.</p> <p>Because of this, it is very important for users to be able to understand and control how timers behave when they are delayed. Timers will handle missed ticks according to a missing tick policy.</p> <p>The following built-in policies are available:</p> <ul> <li><code>SkipMissedAndDrift</code>:     A policy that drops all the missed ticks, triggers immediately and resets.</li> <li><code>SkipMissedAndResync</code>:     A policy that drops all the missed ticks, triggers immediately and resyncs.</li> <li><code>TriggerAllMissed</code>:     A policy that triggers all the missed ticks immediately until it catches up.</li> </ul>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer-classes","title":"Classes","text":""},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.MissedTickPolicy","title":"frequenz.channels.timer.MissedTickPolicy","text":"<p>             Bases: <code>ABC</code></p> <p>A policy to handle timer missed ticks.</p> <p>To implement a custom policy you need to subclass <code>MissedTickPolicy</code> and implement the <code>calculate_next_tick_time</code> method.</p> Example <p>This policy will just wait one more second than the original interval if a tick is missed:</p> <pre><code>class WaitOneMoreSecond(MissedTickPolicy):\n    def calculate_next_tick_time(\n        self, *, interval: int, scheduled_tick_time: int, now: int\n    ) -&gt; int:\n        return scheduled_tick_time + interval + 1_000_000\n\n\nasync def main() -&gt; None:\n    timer = Timer(\n        interval=timedelta(seconds=1),\n        missed_tick_policy=WaitOneMoreSecond(),\n    )\n\n    async for drift in timer:\n        print(f\"The timer has triggered with a drift of {drift}\")\n\nasyncio.run(main())\n</code></pre> Source code in <code>frequenz/channels/timer.py</code> <pre><code>class MissedTickPolicy(abc.ABC):\n    \"\"\"A policy to handle timer missed ticks.\n\n    To implement a custom policy you need to subclass\n    [`MissedTickPolicy`][frequenz.channels.timer.MissedTickPolicy] and implement the\n    [`calculate_next_tick_time`][frequenz.channels.timer.MissedTickPolicy.calculate_next_tick_time]\n    method.\n\n    Example:\n        This policy will just wait one more second than the original interval if a\n        tick is missed:\n\n        ```python\n        class WaitOneMoreSecond(MissedTickPolicy):\n            def calculate_next_tick_time(\n                self, *, interval: int, scheduled_tick_time: int, now: int\n            ) -&gt; int:\n                return scheduled_tick_time + interval + 1_000_000\n\n\n        async def main() -&gt; None:\n            timer = Timer(\n                interval=timedelta(seconds=1),\n                missed_tick_policy=WaitOneMoreSecond(),\n            )\n\n            async for drift in timer:\n                print(f\"The timer has triggered with a drift of {drift}\")\n\n        asyncio.run(main())\n        ```\n    \"\"\"\n\n    @abc.abstractmethod\n    def calculate_next_tick_time(\n        self, *, interval: int, scheduled_tick_time: int, now: int\n    ) -&gt; int:\n        \"\"\"Calculate the next tick time according to `missed_tick_policy`.\n\n        This method is called by `ready()` after it has determined that the\n        timer has triggered.  It will check if the timer has missed any ticks\n        and handle them according to `missed_tick_policy`.\n\n        Args:\n            interval: The interval between ticks (in microseconds).\n            scheduled_tick_time: The time the current tick was scheduled to\n                trigger (in microseconds).\n            now: The current loop time (in microseconds).\n\n        Returns:\n            The next tick time (in microseconds) according to\n                `missed_tick_policy`.\n        \"\"\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this policy.\"\"\"\n        return f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.MissedTickPolicy-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.MissedTickPolicy.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this policy.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this policy.\"\"\"\n    return f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.MissedTickPolicy.calculate_next_tick_time","title":"calculate_next_tick_time  <code>abstractmethod</code>","text":"<pre><code>calculate_next_tick_time(\n    *, interval: int, scheduled_tick_time: int, now: int\n) -&gt; int\n</code></pre> <p>Calculate the next tick time according to <code>missed_tick_policy</code>.</p> <p>This method is called by <code>ready()</code> after it has determined that the timer has triggered.  It will check if the timer has missed any ticks and handle them according to <code>missed_tick_policy</code>.</p> PARAMETER  DESCRIPTION <code>interval</code> <p>The interval between ticks (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>scheduled_tick_time</code> <p>The time the current tick was scheduled to trigger (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>now</code> <p>The current loop time (in microseconds).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The next tick time (in microseconds) according to <code>missed_tick_policy</code>.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>@abc.abstractmethod\ndef calculate_next_tick_time(\n    self, *, interval: int, scheduled_tick_time: int, now: int\n) -&gt; int:\n    \"\"\"Calculate the next tick time according to `missed_tick_policy`.\n\n    This method is called by `ready()` after it has determined that the\n    timer has triggered.  It will check if the timer has missed any ticks\n    and handle them according to `missed_tick_policy`.\n\n    Args:\n        interval: The interval between ticks (in microseconds).\n        scheduled_tick_time: The time the current tick was scheduled to\n            trigger (in microseconds).\n        now: The current loop time (in microseconds).\n\n    Returns:\n        The next tick time (in microseconds) according to\n            `missed_tick_policy`.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndDrift","title":"frequenz.channels.timer.SkipMissedAndDrift","text":"<p>             Bases: <code>MissedTickPolicy</code></p> <p>A policy that drops all the missed ticks, triggers immediately and resets.</p> <p>The <code>SkipMissedAndDrift</code> policy will behave effectively as if the timer was reset every time it is triggered. This means the start time will change and the drift will be accumulated each time a tick is delayed. Only the relative drift will be returned on each tick.</p> <p>The reset happens only if the delay is larger than the delay tolerance, so it is possible to ignore small delays and not drift in those cases.</p> Example <p>This example represents a timer with interval 1 second and delay tolerance of 0.1 seconds.</p> <ol> <li> <p>The first tick, <code>T0</code>, happens exactly at time 0.</p> </li> <li> <p>The second tick, <code>T1.2</code>, happens at time 1.2 (0.2 seconds late), so the timer     triggers immediately but drifts a bit (0.2 seconds), so the next tick is     expected at 2.2 seconds.</p> </li> <li> <p>The third tick, <code>T2.2</code>, happens at 2.3 seconds (0.1 seconds late), so it also     triggers immediately but it doesn't drift because the delay is under     the <code>delay_tolerance</code>. The next tick is expected at 3.2 seconds.</p> </li> <li> <p>The fourth tick, <code>T4.2</code>, triggers at 4.3 seconds (1.1 seconds late), so it     also triggers immediately but the timer has drifted by 1.1 seconds, so a     potential tick <code>T3.2</code> is skipped (not triggered).</p> </li> <li> <p>The fifth tick, <code>T5.3</code>, triggers at 5.3 seconds so it is right on time (no     drift) and the same happens for tick <code>T6.3</code>, which triggers at 6.3 seconds.</p> </li> </ol> <p> <p> 0 1 2 3 4 5 6 T0 T1.2 T2.2 T3.2 T4.2 T5.3 T6.3 time Expected ticks Delivered ticks Undelivered ticks (skipped) </p> <p></p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>class SkipMissedAndDrift(MissedTickPolicy):\n    \"\"\"A policy that drops all the missed ticks, triggers immediately and resets.\n\n    The [`SkipMissedAndDrift`][frequenz.channels.timer.SkipMissedAndDrift] policy will\n    behave effectively as if the timer was\n    [reset][frequenz.channels.timer.Timer.reset] every time it is triggered. This means\n    the start time will change and the drift will be accumulated each time a tick is\n    delayed. Only the relative drift will be returned on each tick.\n\n    The reset happens only if the delay is larger than the\n    [delay tolerance][frequenz.channels.timer.SkipMissedAndDrift.delay_tolerance], so it\n    is possible to ignore small delays and not drift in those cases.\n\n    Example:\n        This example represents a timer with interval 1 second and delay tolerance of\n        0.1 seconds.\n\n        1. The first tick, `T0`, happens exactly at time 0.\n\n        2. The second tick, `T1.2`, happens at time 1.2 (0.2 seconds late), so the timer\n            triggers immediately but drifts a bit (0.2 seconds), so the next tick is\n            expected at 2.2 seconds.\n\n        3. The third tick, `T2.2`, happens at 2.3 seconds (0.1 seconds late), so it also\n            triggers immediately but **it doesn't drift** because the delay is **under\n            the `delay_tolerance`**. The next tick is expected at 3.2 seconds.\n\n        4. The fourth tick, `T4.2`, triggers at 4.3 seconds (1.1 seconds late), so it\n            also triggers immediately but the timer has drifted by 1.1 seconds, so a\n            potential tick `T3.2` is skipped (not triggered).\n\n        5. The fifth tick, `T5.3`, triggers at 5.3 seconds so it is right on time (no\n            drift) and the same happens for tick `T6.3`, which triggers at 6.3 seconds.\n\n        &lt;center&gt;\n        ```bob\n        0         1         2         3         4         5         6\n        *---------o-*-------|-o*------|-O-------|-o*------|--*------|--*--&gt; time\n        T0          T1.2       T2.2     T3.2       T4.2      T5.3      T6.3\n\n        -o- \"Expected ticks\"\n        -*- \"Delivered ticks\"\n        -O- \"Undelivered ticks (skipped)\"\n        ```\n        &lt;/center&gt;\n    \"\"\"\n\n    def __init__(self, *, delay_tolerance: timedelta = timedelta(0)):\n        \"\"\"Initialize this policy.\n\n        See the class documentation for more details.\n\n        Args:\n            delay_tolerance: The maximum delay that is tolerated before\n                starting to drift.  If a tick is delayed less than this, then\n                it is not considered a missed tick and the timer doesn't\n                accumulate this drift.\n\n        Raises:\n            ValueError: If `delay_tolerance` is negative.\n        \"\"\"\n        self._tolerance: int = _to_microseconds(delay_tolerance)\n        \"\"\"The maximum allowed delay before starting to drift.\"\"\"\n\n        if self._tolerance &lt; 0:\n            raise ValueError(\"delay_tolerance must be positive\")\n\n    @property\n    def delay_tolerance(self) -&gt; timedelta:\n        \"\"\"The maximum delay that is tolerated before starting to drift.\"\"\"\n        return timedelta(microseconds=self._tolerance)\n\n    def calculate_next_tick_time(\n        self, *, now: int, scheduled_tick_time: int, interval: int\n    ) -&gt; int:\n        \"\"\"Calculate the next tick time.\n\n        If the drift is larger than `delay_tolerance`, then it returns `now +\n        interval` (so the timer drifts), otherwise it returns\n        `scheduled_tick_time + interval` (we consider the delay too small and\n        avoid small drifts).\n\n        Args:\n            now: The current loop time (in microseconds).\n            scheduled_tick_time: The time the current tick was scheduled to\n                trigger (in microseconds).\n            interval: The interval between ticks (in microseconds).\n\n        Returns:\n            The next tick time (in microseconds).\n        \"\"\"\n        drift = now - scheduled_tick_time\n        if drift &gt; self._tolerance:\n            return now + interval\n        return scheduled_tick_time + interval\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this policy.\"\"\"\n        return f\"{type(self).__name__}()\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this policy.\"\"\"\n        return f\"{type(self).__name__}({self.delay_tolerance=})\"\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndDrift-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndDrift.delay_tolerance","title":"delay_tolerance  <code>property</code>","text":"<pre><code>delay_tolerance: timedelta\n</code></pre> <p>The maximum delay that is tolerated before starting to drift.</p>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndDrift-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndDrift.__init__","title":"__init__","text":"<pre><code>__init__(*, delay_tolerance: timedelta = timedelta(0))\n</code></pre> <p>Initialize this policy.</p> <p>See the class documentation for more details.</p> PARAMETER  DESCRIPTION <code>delay_tolerance</code> <p>The maximum delay that is tolerated before starting to drift.  If a tick is delayed less than this, then it is not considered a missed tick and the timer doesn't accumulate this drift.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(0)</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>delay_tolerance</code> is negative.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def __init__(self, *, delay_tolerance: timedelta = timedelta(0)):\n    \"\"\"Initialize this policy.\n\n    See the class documentation for more details.\n\n    Args:\n        delay_tolerance: The maximum delay that is tolerated before\n            starting to drift.  If a tick is delayed less than this, then\n            it is not considered a missed tick and the timer doesn't\n            accumulate this drift.\n\n    Raises:\n        ValueError: If `delay_tolerance` is negative.\n    \"\"\"\n    self._tolerance: int = _to_microseconds(delay_tolerance)\n    \"\"\"The maximum allowed delay before starting to drift.\"\"\"\n\n    if self._tolerance &lt; 0:\n        raise ValueError(\"delay_tolerance must be positive\")\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndDrift.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this policy.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this policy.\"\"\"\n    return f\"{type(self).__name__}({self.delay_tolerance=})\"\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndDrift.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this policy.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this policy.\"\"\"\n    return f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndDrift.calculate_next_tick_time","title":"calculate_next_tick_time","text":"<pre><code>calculate_next_tick_time(\n    *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int\n</code></pre> <p>Calculate the next tick time.</p> <p>If the drift is larger than <code>delay_tolerance</code>, then it returns <code>now + interval</code> (so the timer drifts), otherwise it returns <code>scheduled_tick_time + interval</code> (we consider the delay too small and avoid small drifts).</p> PARAMETER  DESCRIPTION <code>now</code> <p>The current loop time (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>scheduled_tick_time</code> <p>The time the current tick was scheduled to trigger (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>interval</code> <p>The interval between ticks (in microseconds).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The next tick time (in microseconds).</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def calculate_next_tick_time(\n    self, *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int:\n    \"\"\"Calculate the next tick time.\n\n    If the drift is larger than `delay_tolerance`, then it returns `now +\n    interval` (so the timer drifts), otherwise it returns\n    `scheduled_tick_time + interval` (we consider the delay too small and\n    avoid small drifts).\n\n    Args:\n        now: The current loop time (in microseconds).\n        scheduled_tick_time: The time the current tick was scheduled to\n            trigger (in microseconds).\n        interval: The interval between ticks (in microseconds).\n\n    Returns:\n        The next tick time (in microseconds).\n    \"\"\"\n    drift = now - scheduled_tick_time\n    if drift &gt; self._tolerance:\n        return now + interval\n    return scheduled_tick_time + interval\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndResync","title":"frequenz.channels.timer.SkipMissedAndResync","text":"<p>             Bases: <code>MissedTickPolicy</code></p> <p>A policy that drops all the missed ticks, triggers immediately and resyncs.</p> <p>If ticks are missed, the <code>SkipMissedAndResync</code> policy will make the <code>Timer</code> trigger immediately and it will schedule to trigger again on the next multiple of the interval, effectively skipping any missed ticks, but re-syncing with the original start time.</p> Example <p>This example represents a timer with interval 1 second.</p> <ol> <li> <p>The first tick <code>T0</code> happens exactly at time 0.</p> </li> <li> <p>The second tick, <code>T1</code>, happens at time 1.2 (0.2 seconds late), so it triggers     immediately. But it re-syncs, so the next tick is still expected at     2 seconds. This re-sync happens on every tick, so all ticks are expected at     multiples of 1 second, not matter how delayed they were.</p> </li> <li> <p>The third tick, <code>T2</code>, happens at time 2.3 (0.3 seconds late), so it also     triggers immediately.</p> </li> <li> <p>The fourth tick, <code>T3</code>, happens at time 4.3 (1.3 seconds late), so it also     triggers immediately, but there was also a tick expected at 4 seconds, <code>T4</code>,     which is skipped according to this policy to avoid bursts of ticks.</p> </li> <li> <p>The sixth tick, <code>T5</code>, happens at 5.1 (0.1 seconds late), so it triggers     immediately again.</p> </li> <li> <p>The seventh tick, <code>T6</code>, happens at 6.0, right on time.</p> </li> </ol> <p> <p> 0 1 2 3 4 T4 5 6 T0 T1 T2 T3 T5 T6 time Expected ticks Delivered ticks Undelivered ticks (skipped) </p> <p></p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>class SkipMissedAndResync(MissedTickPolicy):\n    \"\"\"A policy that drops all the missed ticks, triggers immediately and resyncs.\n\n    If ticks are missed, the\n    [`SkipMissedAndResync`][frequenz.channels.timer.SkipMissedAndResync] policy will\n    make the [`Timer`][frequenz.channels.timer.Timer] trigger immediately and it will\n    schedule to trigger again on the next multiple of the\n    [interval][frequenz.channels.timer.Timer.interval], effectively skipping any missed\n    ticks, but re-syncing with the original start time.\n\n    Example:\n        This example represents a timer with interval 1 second.\n\n        1. The first tick `T0` happens exactly at time 0.\n\n        2. The second tick, `T1`, happens at time 1.2 (0.2 seconds late), so it triggers\n            immediately. But it re-syncs, so the next tick is still expected at\n            2 seconds. This re-sync happens on every tick, so all ticks are expected at\n            multiples of 1 second, not matter how delayed they were.\n\n        3. The third tick, `T2`, happens at time 2.3 (0.3 seconds late), so it also\n            triggers immediately.\n\n        4. The fourth tick, `T3`, happens at time 4.3 (1.3 seconds late), so it also\n            triggers immediately, but there was also a tick expected at 4 seconds, `T4`,\n            which is skipped according to this policy to avoid bursts of ticks.\n\n        6. The sixth tick, `T5`, happens at 5.1 (0.1 seconds late), so it triggers\n            immediately again.\n\n        7. The seventh tick, `T6`, happens at 6.0, right on time.\n\n        &lt;center&gt;\n        ```bob\n        0         1         2         3         4   T4    5         6\n        *---------o-*-------o--*------o---------o--*O-----o-*-------*-----&gt; time\n        T0          T1         T2                  T3       T5      T6\n\n        -o- \"Expected ticks\"\n        -*- \"Delivered ticks\"\n        -O- \"Undelivered ticks (skipped)\"\n        ```\n        &lt;/center&gt;\n    \"\"\"\n\n    def calculate_next_tick_time(\n        self, *, now: int, scheduled_tick_time: int, interval: int\n    ) -&gt; int:\n        \"\"\"Calculate the next tick time.\n\n        Calculate the next multiple of `interval` after `scheduled_tick_time`.\n\n        Args:\n            now: The current loop time (in microseconds).\n            scheduled_tick_time: The time the current tick was scheduled to\n                trigger (in microseconds).\n            interval: The interval between ticks (in microseconds).\n\n        Returns:\n            The next tick time (in microseconds).\n        \"\"\"\n        # We need to resync (align) the next tick time to the current time\n        drift = now - scheduled_tick_time\n        delta_to_next_tick = interval - (drift % interval)\n        return now + delta_to_next_tick\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndResync-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndResync.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this policy.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this policy.\"\"\"\n    return f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.SkipMissedAndResync.calculate_next_tick_time","title":"calculate_next_tick_time","text":"<pre><code>calculate_next_tick_time(\n    *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int\n</code></pre> <p>Calculate the next tick time.</p> <p>Calculate the next multiple of <code>interval</code> after <code>scheduled_tick_time</code>.</p> PARAMETER  DESCRIPTION <code>now</code> <p>The current loop time (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>scheduled_tick_time</code> <p>The time the current tick was scheduled to trigger (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>interval</code> <p>The interval between ticks (in microseconds).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The next tick time (in microseconds).</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def calculate_next_tick_time(\n    self, *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int:\n    \"\"\"Calculate the next tick time.\n\n    Calculate the next multiple of `interval` after `scheduled_tick_time`.\n\n    Args:\n        now: The current loop time (in microseconds).\n        scheduled_tick_time: The time the current tick was scheduled to\n            trigger (in microseconds).\n        interval: The interval between ticks (in microseconds).\n\n    Returns:\n        The next tick time (in microseconds).\n    \"\"\"\n    # We need to resync (align) the next tick time to the current time\n    drift = now - scheduled_tick_time\n    delta_to_next_tick = interval - (drift % interval)\n    return now + delta_to_next_tick\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer","title":"frequenz.channels.timer.Timer","text":"<p>             Bases: <code>Receiver[timedelta]</code></p> <p>A receiver that sends a message regularly.</p> <p><code>Timer</code>s are started by default after they are created. This can be disabled by using <code>auto_start=False</code> option when creating them. In this case, the timer will not be started until <code>reset()</code> is called. Receiving from the timer (either using <code>receive()</code> or using the async iterator interface) will also start the timer at that point.</p> <p>Timers need to be created in a context where a <code>asyncio</code> loop is already running. If no <code>loop</code> is specified, the current running loop is used.</p> <p>Timers can be stopped by calling <code>stop()</code>. A stopped timer will raise a <code>ReceiverStoppedError</code> or stop the async iteration as usual.</p> <p>Once a timer is explicitly stopped, it can only be started again by explicitly calling <code>reset()</code> (trying to receive from it or using the async iterator interface will keep failing).</p> <p>Timer messages are <code>timedelta</code>s containing the drift of the timer, i.e. the difference between when the timer should have triggered and the time when it actually triggered.</p> <p>This drift will likely never be <code>0</code>, because if there is a task that is running when it should trigger, the timer will be delayed. In this case the drift will be positive. A negative drift should be technically impossible, as the timer uses <code>asyncio</code>s loop monotonic clock.</p> Warning <p>Even when the <code>asyncio</code> loop's monotonic clock is a <code>float</code>, timers use <code>int</code>s to represent time internally. The internal time is tracked in microseconds, so the timer resolution is 1 microsecond (<code>interval</code> must be at least  1 microsecond).</p> <p>This is to avoid floating point errors when performing calculations with time, which can lead to issues that are very hard to reproduce and debug.</p> <p>If the timer is delayed too much, then it will behave according to the <code>missed_tick_policy</code>. Missing ticks might or might not trigger a message and the drift could be accumulated or not depending on the chosen policy.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>class Timer(Receiver[timedelta]):\n    \"\"\"A receiver that sends a message regularly.\n\n    [`Timer`][frequenz.channels.timer.Timer]s are started by default after they are\n    created. This can be disabled by using `auto_start=False` option when creating\n    them. In this case, the timer will not be started until\n    [`reset()`][frequenz.channels.timer.Timer.reset] is called. Receiving from the timer\n    (either using [`receive()`][frequenz.channels.timer.Timer.receive] or using the\n    async iterator interface) will also start the timer at that point.\n\n    Timers need to be created in a context where\n    a [`asyncio`][] loop is already running. If no\n    [`loop`][frequenz.channels.timer.Timer.loop] is specified, the current running loop\n    is used.\n\n    Timers can be stopped by calling [`stop()`][frequenz.channels.timer.Timer.stop].\n    A stopped timer will raise\n    a [`ReceiverStoppedError`][frequenz.channels.ReceiverStoppedError] or stop the async\n    iteration as usual.\n\n    Once a timer is explicitly stopped, it can only be started again by explicitly\n    calling [`reset()`][frequenz.channels.timer.Timer.reset] (trying to receive from it\n    or using the async iterator interface will keep failing).\n\n    Timer messages are [`timedelta`][datetime.timedelta]s containing the drift of the\n    timer, i.e. the difference between when the timer should have triggered and the time\n    when it actually triggered.\n\n    This drift will likely never be `0`, because if there is a task that is\n    running when it should trigger, the timer will be delayed. In this case the\n    drift will be positive. A negative drift should be technically impossible,\n    as the timer uses [`asyncio`][]s loop monotonic clock.\n\n    Warning:\n        Even when the [`asyncio`][] loop's monotonic clock is a [`float`][], timers use\n        `int`s to represent time internally. The internal time is tracked in\n        microseconds, so the timer resolution is 1 microsecond\n        ([`interval`][frequenz.channels.timer.Timer.interval] must be at least\n         1 microsecond).\n\n        This is to avoid floating point errors when performing calculations with time,\n        which can lead to issues that are very hard to reproduce and debug.\n\n    If the timer is delayed too much, then it will behave according to the\n    [`missed_tick_policy`][frequenz.channels.timer.Timer.missed_tick_policy]. Missing\n    ticks might or might not trigger a message and the drift could be accumulated or not\n    depending on the chosen policy.\n    \"\"\"\n\n    def __init__(  # pylint: disable=too-many-arguments\n        self,\n        interval: timedelta,\n        missed_tick_policy: MissedTickPolicy,\n        /,\n        *,\n        auto_start: bool = True,\n        start_delay: timedelta = timedelta(0),\n        loop: asyncio.AbstractEventLoop | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize this timer.\n\n        See the [class documentation][frequenz.channels.timer.Timer] for details.\n\n        Args:\n            interval: The time between timer ticks. Must be at least\n                1 microsecond.\n            missed_tick_policy: The policy of the timer when it misses a tick.\n                Commonly one of `TriggerAllMissed`, `SkipMissedAndResync`, `SkipMissedAndDrift`\n                or a custom class deriving from `MissedTickPolicy`. See the\n                documentation of the each class for more details.\n            auto_start: Whether the timer should be started when the\n                instance is created. This can only be `True` if there is\n                already a running loop or an explicit `loop` that is running\n                was passed.\n            start_delay: The delay before the timer should start. If `auto_start` is\n                `False`, an exception is raised. This has microseconds resolution,\n                anything smaller than a microsecond means no delay.\n            loop: The event loop to use to track time. If `None`,\n                `asyncio.get_running_loop()` will be used.\n\n        Raises:\n            RuntimeError: If it was called without a loop and there is no\n                running loop.\n            ValueError: If `interval` is not positive or is smaller than 1\n                microsecond; if `start_delay` is negative or `start_delay` was specified\n                but `auto_start` is `False`.\n        \"\"\"\n        if interval &lt; timedelta(microseconds=1):\n            raise ValueError(\n                f\"The `interval` must be positive and at least 1 microsecond, not {interval}\"\n            )\n\n        if start_delay &gt; timedelta(0) and auto_start is False:\n            raise ValueError(\n                \"`auto_start` must be `True` if a `start_delay` is specified\"\n            )\n\n        self._interval: int = _to_microseconds(interval)\n        \"\"\"The time to between timer ticks.\"\"\"\n\n        self._missed_tick_policy: MissedTickPolicy = missed_tick_policy\n        \"\"\"The policy of the timer when it misses a tick.\n\n        See the documentation of `MissedTickPolicy` for details.\n        \"\"\"\n\n        self._loop: asyncio.AbstractEventLoop = (\n            loop if loop is not None else asyncio.get_running_loop()\n        )\n        \"\"\"The event loop to use to track time.\"\"\"\n\n        self._stopped: bool = True\n        \"\"\"Whether the timer was requested to stop.\n\n        If this is `False`, then the timer is running.\n\n        If this is `True`, then it is stopped or there is a request to stop it\n        or it was not started yet:\n\n        * If `_next_msg_time` is `None`, it means it wasn't started yet (it was\n          created with `auto_start=False`).  Any receiving method will start\n          it by calling `reset()` in this case.\n\n        * If `_next_msg_time` is not `None`, it means there was a request to\n          stop it.  In this case receiving methods will raise\n          a `ReceiverClosedError`.\n        \"\"\"\n\n        self._next_tick_time: int | None = None\n        \"\"\"The absolute (monotonic) time when the timer should trigger.\n\n        If this is `None`, it means the timer didn't start yet, but it should\n        be started as soon as it is used.\n        \"\"\"\n\n        self._current_drift: timedelta | None = None\n        \"\"\"The difference between `_next_msg_time` and the triggered time.\n\n        This is calculated by `ready()` but is returned by `consume()`. If\n        `None` it means `ready()` wasn't called and `consume()` will assert.\n        `consume()` will set it back to `None` to tell `ready()` that it needs\n        to wait again.\n        \"\"\"\n\n        if auto_start:\n            self.reset(start_delay=start_delay)\n\n    @property\n    def interval(self) -&gt; timedelta:\n        \"\"\"The interval between timer ticks.\"\"\"\n        return timedelta(microseconds=self._interval)\n\n    @property\n    def missed_tick_policy(self) -&gt; MissedTickPolicy:\n        \"\"\"The policy of the timer when it misses a tick.\"\"\"\n        return self._missed_tick_policy\n\n    @property\n    def loop(self) -&gt; asyncio.AbstractEventLoop:\n        \"\"\"The event loop used by the timer to track time.\"\"\"\n        return self._loop\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Whether the timer is running.\"\"\"\n        return not self._stopped\n\n    def reset(self, *, start_delay: timedelta = timedelta(0)) -&gt; None:\n        \"\"\"Reset the timer to start timing from now (plus an optional delay).\n\n        If the timer was stopped, or not started yet, it will be started.\n\n        This can only be called with a running loop, see the class documentation for\n        more details.\n\n        Args:\n            start_delay: The delay before the timer should start. This has microseconds\n                resolution, anything smaller than a microsecond means no delay.\n\n        Raises:\n            RuntimeError: If it was called without a running loop.\n            ValueError: If `start_delay` is negative.\n        \"\"\"\n        start_delay_ms = _to_microseconds(start_delay)\n\n        if start_delay_ms &lt; 0:\n            raise ValueError(f\"`start_delay` can't be negative, got {start_delay}\")\n        self._stopped = False\n        self._next_tick_time = self._now() + start_delay_ms + self._interval\n        self._current_drift = None\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the timer.\n\n        Once `stop` has been called, all subsequent calls to `ready()` will\n        immediately return False and calls to `consume()` / `receive()` or any\n        use of the async iterator interface will raise\n        a `ReceiverStoppedError`.\n\n        You can restart the timer with `reset()`.\n        \"\"\"\n        self._stopped = True\n        # We need to make sure it's not None, otherwise `ready()` will start it\n        self._next_tick_time = self._now()\n\n    # We need a noqa here because the docs have a Raises section but the documented\n    # exceptions are raised indirectly.\n    async def ready(self) -&gt; bool:  # noqa: DOC502\n        \"\"\"Wait until the timer `interval` passed.\n\n        Once a call to `ready()` has finished, the resulting tick information\n        must be read with a call to `consume()` (`receive()` or iterated over)\n        to tell the timer it should wait for the next interval.\n\n        The timer will remain ready (this method will return immediately)\n        until it is consumed.\n\n        Returns:\n            Whether the timer was started and it is still running.\n\n        Raises:\n            RuntimeError: If it was called without a running loop.\n        \"\"\"\n        # If there are messages waiting to be consumed, return immediately.\n        if self._current_drift is not None:\n            return True\n\n        # If `_next_tick_time` is `None`, it means it was created with\n        # `auto_start=False` and should be started.\n        if self._next_tick_time is None:\n            self.reset()\n            assert (\n                self._next_tick_time is not None\n            ), \"This should be assigned by reset()\"\n\n        # If a stop was explicitly requested, we bail out.\n        if self._stopped:\n            return False\n\n        now = self._now()\n        time_to_next_tick = self._next_tick_time - now\n\n        # If we didn't reach the tick yet, sleep until we do.\n        # We need to do this in a loop also reacting to the reset event, as the timer\n        # could be reset while we are sleeping, in which case we need to recalculate\n        # the time to the next tick and try again.\n        while time_to_next_tick &gt; 0:\n            await asyncio.sleep(time_to_next_tick / 1_000_000)\n            now = self._now()\n            time_to_next_tick = self._next_tick_time - now\n\n        # If a stop was explicitly requested during the sleep, we bail out.\n        if self._stopped:\n            return False\n\n        self._current_drift = timedelta(microseconds=now - self._next_tick_time)\n        self._next_tick_time = self._missed_tick_policy.calculate_next_tick_time(\n            now=now,\n            scheduled_tick_time=self._next_tick_time,\n            interval=self._interval,\n        )\n\n        return True\n\n    def consume(self) -&gt; timedelta:\n        \"\"\"Return the latest drift once `ready()` is complete.\n\n        Once the timer has triggered (`ready()` is done), this method returns the\n        difference between when the timer should have triggered and the time when\n        it actually triggered. See the class documentation for more details.\n\n        Returns:\n            The difference between when the timer should have triggered and the\n                time when it actually did.\n\n        Raises:\n            ReceiverStoppedError: If the timer was stopped via `stop()`.\n        \"\"\"\n        # If it was stopped and there it no pending result, we raise\n        # (if there is a pending result, then we still want to return it first)\n        if self._stopped and self._current_drift is None:\n            raise ReceiverStoppedError(self)\n\n        assert (\n            self._current_drift is not None\n        ), \"calls to `consume()` must be follow a call to `ready()`\"\n        drift = self._current_drift\n        self._current_drift = None\n        return drift\n\n    def _now(self) -&gt; int:\n        \"\"\"Return the current monotonic clock time in microseconds.\n\n        Returns:\n            The current monotonic clock time in microseconds.\n        \"\"\"\n        return _to_microseconds(self._loop.time())\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this timer.\"\"\"\n        return f\"{type(self).__name__}({self.interval})\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string with the internal representation of this timer.\"\"\"\n        return (\n            f\"{type(self).__name__}&lt;{self.interval=}, {self.missed_tick_policy=}, \"\n            f\"{self.loop=}, {self.is_running=}&gt;\"\n        )\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.interval","title":"interval  <code>property</code>","text":"<pre><code>interval: timedelta\n</code></pre> <p>The interval between timer ticks.</p>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Whether the timer is running.</p>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.loop","title":"loop  <code>property</code>","text":"<pre><code>loop: AbstractEventLoop\n</code></pre> <p>The event loop used by the timer to track time.</p>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.missed_tick_policy","title":"missed_tick_policy  <code>property</code>","text":"<pre><code>missed_tick_policy: MissedTickPolicy\n</code></pre> <p>The policy of the timer when it misses a tick.</p>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.__aiter__","title":"__aiter__","text":"<pre><code>__aiter__() -&gt; Self\n</code></pre> <p>Get an async iterator over the received messages.</p> RETURNS DESCRIPTION <code>Self</code> <p>This receiver, as it is already an async iterator.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def __aiter__(self) -&gt; Self:\n    \"\"\"Get an async iterator over the received messages.\n\n    Returns:\n        This receiver, as it is already an async iterator.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.__anext__","title":"__anext__  <code>async</code>","text":"<pre><code>__anext__() -&gt; ReceiverMessageT_co\n</code></pre> <p>Await the next message in the async iteration over received messages.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The next received message.</p> RAISES DESCRIPTION <code>StopAsyncIteration</code> <p>If the receiver stopped producing messages.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def __anext__(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Await the next message in the async iteration over received messages.\n\n    Returns:\n        The next received message.\n\n    Raises:\n        StopAsyncIteration: If the receiver stopped producing messages.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        await self.ready()\n        return self.consume()\n    except ReceiverStoppedError as exc:\n        raise StopAsyncIteration() from exc\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.__init__","title":"__init__","text":"<pre><code>__init__(\n    interval: timedelta,\n    missed_tick_policy: MissedTickPolicy,\n    /,\n    *,\n    auto_start: bool = True,\n    start_delay: timedelta = timedelta(0),\n    loop: AbstractEventLoop | None = None,\n) -&gt; None\n</code></pre> <p>Initialize this timer.</p> <p>See the class documentation for details.</p> PARAMETER  DESCRIPTION <code>interval</code> <p>The time between timer ticks. Must be at least 1 microsecond.</p> <p> TYPE: <code>timedelta</code> </p> <code>missed_tick_policy</code> <p>The policy of the timer when it misses a tick. Commonly one of <code>TriggerAllMissed</code>, <code>SkipMissedAndResync</code>, <code>SkipMissedAndDrift</code> or a custom class deriving from <code>MissedTickPolicy</code>. See the documentation of the each class for more details.</p> <p> TYPE: <code>MissedTickPolicy</code> </p> <code>auto_start</code> <p>Whether the timer should be started when the instance is created. This can only be <code>True</code> if there is already a running loop or an explicit <code>loop</code> that is running was passed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>start_delay</code> <p>The delay before the timer should start. If <code>auto_start</code> is <code>False</code>, an exception is raised. This has microseconds resolution, anything smaller than a microsecond means no delay.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(0)</code> </p> <code>loop</code> <p>The event loop to use to track time. If <code>None</code>, <code>asyncio.get_running_loop()</code> will be used.</p> <p> TYPE: <code>AbstractEventLoop | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If it was called without a loop and there is no running loop.</p> <code>ValueError</code> <p>If <code>interval</code> is not positive or is smaller than 1 microsecond; if <code>start_delay</code> is negative or <code>start_delay</code> was specified but <code>auto_start</code> is <code>False</code>.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\n    self,\n    interval: timedelta,\n    missed_tick_policy: MissedTickPolicy,\n    /,\n    *,\n    auto_start: bool = True,\n    start_delay: timedelta = timedelta(0),\n    loop: asyncio.AbstractEventLoop | None = None,\n) -&gt; None:\n    \"\"\"Initialize this timer.\n\n    See the [class documentation][frequenz.channels.timer.Timer] for details.\n\n    Args:\n        interval: The time between timer ticks. Must be at least\n            1 microsecond.\n        missed_tick_policy: The policy of the timer when it misses a tick.\n            Commonly one of `TriggerAllMissed`, `SkipMissedAndResync`, `SkipMissedAndDrift`\n            or a custom class deriving from `MissedTickPolicy`. See the\n            documentation of the each class for more details.\n        auto_start: Whether the timer should be started when the\n            instance is created. This can only be `True` if there is\n            already a running loop or an explicit `loop` that is running\n            was passed.\n        start_delay: The delay before the timer should start. If `auto_start` is\n            `False`, an exception is raised. This has microseconds resolution,\n            anything smaller than a microsecond means no delay.\n        loop: The event loop to use to track time. If `None`,\n            `asyncio.get_running_loop()` will be used.\n\n    Raises:\n        RuntimeError: If it was called without a loop and there is no\n            running loop.\n        ValueError: If `interval` is not positive or is smaller than 1\n            microsecond; if `start_delay` is negative or `start_delay` was specified\n            but `auto_start` is `False`.\n    \"\"\"\n    if interval &lt; timedelta(microseconds=1):\n        raise ValueError(\n            f\"The `interval` must be positive and at least 1 microsecond, not {interval}\"\n        )\n\n    if start_delay &gt; timedelta(0) and auto_start is False:\n        raise ValueError(\n            \"`auto_start` must be `True` if a `start_delay` is specified\"\n        )\n\n    self._interval: int = _to_microseconds(interval)\n    \"\"\"The time to between timer ticks.\"\"\"\n\n    self._missed_tick_policy: MissedTickPolicy = missed_tick_policy\n    \"\"\"The policy of the timer when it misses a tick.\n\n    See the documentation of `MissedTickPolicy` for details.\n    \"\"\"\n\n    self._loop: asyncio.AbstractEventLoop = (\n        loop if loop is not None else asyncio.get_running_loop()\n    )\n    \"\"\"The event loop to use to track time.\"\"\"\n\n    self._stopped: bool = True\n    \"\"\"Whether the timer was requested to stop.\n\n    If this is `False`, then the timer is running.\n\n    If this is `True`, then it is stopped or there is a request to stop it\n    or it was not started yet:\n\n    * If `_next_msg_time` is `None`, it means it wasn't started yet (it was\n      created with `auto_start=False`).  Any receiving method will start\n      it by calling `reset()` in this case.\n\n    * If `_next_msg_time` is not `None`, it means there was a request to\n      stop it.  In this case receiving methods will raise\n      a `ReceiverClosedError`.\n    \"\"\"\n\n    self._next_tick_time: int | None = None\n    \"\"\"The absolute (monotonic) time when the timer should trigger.\n\n    If this is `None`, it means the timer didn't start yet, but it should\n    be started as soon as it is used.\n    \"\"\"\n\n    self._current_drift: timedelta | None = None\n    \"\"\"The difference between `_next_msg_time` and the triggered time.\n\n    This is calculated by `ready()` but is returned by `consume()`. If\n    `None` it means `ready()` wasn't called and `consume()` will assert.\n    `consume()` will set it back to `None` to tell `ready()` that it needs\n    to wait again.\n    \"\"\"\n\n    if auto_start:\n        self.reset(start_delay=start_delay)\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string with the internal representation of this timer.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string with the internal representation of this timer.\"\"\"\n    return (\n        f\"{type(self).__name__}&lt;{self.interval=}, {self.missed_tick_policy=}, \"\n        f\"{self.loop=}, {self.is_running=}&gt;\"\n    )\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this timer.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this timer.\"\"\"\n    return f\"{type(self).__name__}({self.interval})\"\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.consume","title":"consume","text":"<pre><code>consume() -&gt; timedelta\n</code></pre> <p>Return the latest drift once <code>ready()</code> is complete.</p> <p>Once the timer has triggered (<code>ready()</code> is done), this method returns the difference between when the timer should have triggered and the time when it actually triggered. See the class documentation for more details.</p> RETURNS DESCRIPTION <code>timedelta</code> <p>The difference between when the timer should have triggered and the time when it actually did.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If the timer was stopped via <code>stop()</code>.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def consume(self) -&gt; timedelta:\n    \"\"\"Return the latest drift once `ready()` is complete.\n\n    Once the timer has triggered (`ready()` is done), this method returns the\n    difference between when the timer should have triggered and the time when\n    it actually triggered. See the class documentation for more details.\n\n    Returns:\n        The difference between when the timer should have triggered and the\n            time when it actually did.\n\n    Raises:\n        ReceiverStoppedError: If the timer was stopped via `stop()`.\n    \"\"\"\n    # If it was stopped and there it no pending result, we raise\n    # (if there is a pending result, then we still want to return it first)\n    if self._stopped and self._current_drift is None:\n        raise ReceiverStoppedError(self)\n\n    assert (\n        self._current_drift is not None\n    ), \"calls to `consume()` must be follow a call to `ready()`\"\n    drift = self._current_drift\n    self._current_drift = None\n    return drift\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.map","title":"map","text":"<pre><code>map(\n    mapping_function: Callable[\n        [ReceiverMessageT_co], MappedMessageT_co\n    ]\n) -&gt; Receiver[MappedMessageT_co]\n</code></pre> <p>Apply a mapping function on the received message.</p> Tip <p>The returned receiver type won't have all the methods of the original receiver. If you need to access methods of the original receiver that are not part of the <code>Receiver</code> interface you should save a reference to the original receiver and use that instead.</p> PARAMETER  DESCRIPTION <code>mapping_function</code> <p>The function to be applied on incoming messages.</p> <p> TYPE: <code>Callable[[ReceiverMessageT_co], MappedMessageT_co]</code> </p> RETURNS DESCRIPTION <code>Receiver[MappedMessageT_co]</code> <p>A new receiver that applies the function on the received messages.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>def map(\n    self, mapping_function: Callable[[ReceiverMessageT_co], MappedMessageT_co], /\n) -&gt; Receiver[MappedMessageT_co]:\n    \"\"\"Apply a mapping function on the received message.\n\n    Tip:\n        The returned receiver type won't have all the methods of the original\n        receiver. If you need to access methods of the original receiver that are\n        not part of the `Receiver` interface you should save a reference to the\n        original receiver and use that instead.\n\n    Args:\n        mapping_function: The function to be applied on incoming messages.\n\n    Returns:\n        A new receiver that applies the function on the received messages.\n    \"\"\"\n    return _Mapper(receiver=self, mapping_function=mapping_function)\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.ready","title":"ready  <code>async</code>","text":"<pre><code>ready() -&gt; bool\n</code></pre> <p>Wait until the timer <code>interval</code> passed.</p> <p>Once a call to <code>ready()</code> has finished, the resulting tick information must be read with a call to <code>consume()</code> (<code>receive()</code> or iterated over) to tell the timer it should wait for the next interval.</p> <p>The timer will remain ready (this method will return immediately) until it is consumed.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the timer was started and it is still running.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If it was called without a running loop.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>async def ready(self) -&gt; bool:  # noqa: DOC502\n    \"\"\"Wait until the timer `interval` passed.\n\n    Once a call to `ready()` has finished, the resulting tick information\n    must be read with a call to `consume()` (`receive()` or iterated over)\n    to tell the timer it should wait for the next interval.\n\n    The timer will remain ready (this method will return immediately)\n    until it is consumed.\n\n    Returns:\n        Whether the timer was started and it is still running.\n\n    Raises:\n        RuntimeError: If it was called without a running loop.\n    \"\"\"\n    # If there are messages waiting to be consumed, return immediately.\n    if self._current_drift is not None:\n        return True\n\n    # If `_next_tick_time` is `None`, it means it was created with\n    # `auto_start=False` and should be started.\n    if self._next_tick_time is None:\n        self.reset()\n        assert (\n            self._next_tick_time is not None\n        ), \"This should be assigned by reset()\"\n\n    # If a stop was explicitly requested, we bail out.\n    if self._stopped:\n        return False\n\n    now = self._now()\n    time_to_next_tick = self._next_tick_time - now\n\n    # If we didn't reach the tick yet, sleep until we do.\n    # We need to do this in a loop also reacting to the reset event, as the timer\n    # could be reset while we are sleeping, in which case we need to recalculate\n    # the time to the next tick and try again.\n    while time_to_next_tick &gt; 0:\n        await asyncio.sleep(time_to_next_tick / 1_000_000)\n        now = self._now()\n        time_to_next_tick = self._next_tick_time - now\n\n    # If a stop was explicitly requested during the sleep, we bail out.\n    if self._stopped:\n        return False\n\n    self._current_drift = timedelta(microseconds=now - self._next_tick_time)\n    self._next_tick_time = self._missed_tick_policy.calculate_next_tick_time(\n        now=now,\n        scheduled_tick_time=self._next_tick_time,\n        interval=self._interval,\n    )\n\n    return True\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.receive","title":"receive  <code>async</code>","text":"<pre><code>receive() -&gt; ReceiverMessageT_co\n</code></pre> <p>Receive a message.</p> RETURNS DESCRIPTION <code>ReceiverMessageT_co</code> <p>The received message.</p> RAISES DESCRIPTION <code>ReceiverStoppedError</code> <p>If there is some problem with the receiver.</p> <code>ReceiverError</code> <p>If there is some problem with the receiver.</p> Source code in <code>frequenz/channels/_receiver.py</code> <pre><code>async def receive(self) -&gt; ReceiverMessageT_co:\n    \"\"\"Receive a message.\n\n    Returns:\n        The received message.\n\n    Raises:\n        ReceiverStoppedError: If there is some problem with the receiver.\n        ReceiverError: If there is some problem with the receiver.\n    \"\"\"\n    try:\n        received = await self.__anext__()  # pylint: disable=unnecessary-dunder-call\n    except StopAsyncIteration as exc:\n        # If we already had a cause and it was the receiver was stopped,\n        # then reuse that error, as StopAsyncIteration is just an artifact\n        # introduced by __anext__.\n        if (\n            isinstance(exc.__cause__, ReceiverStoppedError)\n            # pylint is not smart enough to figure out we checked above\n            # this is a ReceiverStoppedError and thus it does have\n            # a receiver member\n            and exc.__cause__.receiver is self  # pylint: disable=no-member\n        ):\n            raise exc.__cause__\n        raise ReceiverStoppedError(self) from exc\n    return received\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.reset","title":"reset","text":"<pre><code>reset(*, start_delay: timedelta = timedelta(0)) -&gt; None\n</code></pre> <p>Reset the timer to start timing from now (plus an optional delay).</p> <p>If the timer was stopped, or not started yet, it will be started.</p> <p>This can only be called with a running loop, see the class documentation for more details.</p> PARAMETER  DESCRIPTION <code>start_delay</code> <p>The delay before the timer should start. This has microseconds resolution, anything smaller than a microsecond means no delay.</p> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta(0)</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If it was called without a running loop.</p> <code>ValueError</code> <p>If <code>start_delay</code> is negative.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def reset(self, *, start_delay: timedelta = timedelta(0)) -&gt; None:\n    \"\"\"Reset the timer to start timing from now (plus an optional delay).\n\n    If the timer was stopped, or not started yet, it will be started.\n\n    This can only be called with a running loop, see the class documentation for\n    more details.\n\n    Args:\n        start_delay: The delay before the timer should start. This has microseconds\n            resolution, anything smaller than a microsecond means no delay.\n\n    Raises:\n        RuntimeError: If it was called without a running loop.\n        ValueError: If `start_delay` is negative.\n    \"\"\"\n    start_delay_ms = _to_microseconds(start_delay)\n\n    if start_delay_ms &lt; 0:\n        raise ValueError(f\"`start_delay` can't be negative, got {start_delay}\")\n    self._stopped = False\n    self._next_tick_time = self._now() + start_delay_ms + self._interval\n    self._current_drift = None\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.Timer.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> <p>Stop the timer.</p> <p>Once <code>stop</code> has been called, all subsequent calls to <code>ready()</code> will immediately return False and calls to <code>consume()</code> / <code>receive()</code> or any use of the async iterator interface will raise a <code>ReceiverStoppedError</code>.</p> <p>You can restart the timer with <code>reset()</code>.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the timer.\n\n    Once `stop` has been called, all subsequent calls to `ready()` will\n    immediately return False and calls to `consume()` / `receive()` or any\n    use of the async iterator interface will raise\n    a `ReceiverStoppedError`.\n\n    You can restart the timer with `reset()`.\n    \"\"\"\n    self._stopped = True\n    # We need to make sure it's not None, otherwise `ready()` will start it\n    self._next_tick_time = self._now()\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.TriggerAllMissed","title":"frequenz.channels.timer.TriggerAllMissed","text":"<p>             Bases: <code>MissedTickPolicy</code></p> <p>A policy that triggers all the missed ticks immediately until it catches up.</p> <p>The <code>TriggerAllMissed</code> policy will trigger all missed ticks immediately until it catches up with the current time. This means that if the timer is delayed for any reason, when it finally gets some time to run, it will trigger all the missed ticks in a burst. The drift is not accumulated and the next tick will be scheduled according to the original start time.</p> Example <p>This example represents a timer with interval 1 second.</p> <ol> <li> <p>The first tick, <code>T0</code> happens exactly at time 0.</p> </li> <li> <p>The second tick, <code>T1</code>, happens at time 1.2 (0.2 seconds late), so it triggers     immediately. But it re-syncs, so the next tick is still expected at     2 seconds. This re-sync happens on every tick, so all ticks are expected at     multiples of 1 second, not matter how delayed they were.</p> </li> <li> <p>The third tick, <code>T2</code>, happens at time 2.3 (0.3 seconds late), so it also     triggers immediately.</p> </li> <li> <p>The fourth tick, <code>T3</code>, happens at time 4.3 (1.3 seconds late), so it also     triggers immediately.</p> </li> <li> <p>The fifth tick, <code>T4</code>, which was also already delayed (by 0.3 seconds),     triggers immediately too, resulting in a small catch-up burst.</p> </li> <li> <p>The sixth tick, <code>T5</code>, happens at 5.1 (0.1 seconds late), so it triggers     immediately again.</p> </li> <li> <p>The seventh tick, <code>T6</code>, happens at 6.0, right on time.</p> </li> </ol> <p> <p> 0 1 2 3 4 T4 5 6 T0 T1 T2 T3 T5 T6 time Expected ticks Delivered ticks </p> <p></p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>class TriggerAllMissed(MissedTickPolicy):\n    \"\"\"A policy that triggers all the missed ticks immediately until it catches up.\n\n    The [`TriggerAllMissed`][frequenz.channels.timer.TriggerAllMissed] policy will\n    trigger all missed ticks immediately until it catches up with the current time.\n    This means that if the timer is delayed for any reason, when it finally gets some\n    time to run, it will trigger all the missed ticks in a burst. The drift is not\n    accumulated and the next tick will be scheduled according to the original start\n    time.\n\n    Example:\n        This example represents a timer with interval 1 second.\n\n        1. The first tick, `T0` happens exactly at time 0.\n\n        2. The second tick, `T1`, happens at time 1.2 (0.2 seconds late), so it triggers\n            immediately. But it re-syncs, so the next tick is still expected at\n            2 seconds. This re-sync happens on every tick, so all ticks are expected at\n            multiples of 1 second, not matter how delayed they were.\n\n        3. The third tick, `T2`, happens at time 2.3 (0.3 seconds late), so it also\n            triggers immediately.\n\n        4. The fourth tick, `T3`, happens at time 4.3 (1.3 seconds late), so it also\n            triggers immediately.\n\n        5. The fifth tick, `T4`, which was also already delayed (by 0.3 seconds),\n            triggers immediately too, resulting in a small *catch-up* burst.\n\n        6. The sixth tick, `T5`, happens at 5.1 (0.1 seconds late), so it triggers\n            immediately again.\n\n        7. The seventh tick, `T6`, happens at 6.0, right on time.\n\n        &lt;center&gt;\n        ```bob\n        0         1         2         3         4   T4    5         6\n        *---------o-*-------o--*------o---------o--**-----o*--------*-----&gt; time\n        T0          T1         T2                  T3      T5       T6\n\n        -o- \"Expected ticks\"\n        -*- \"Delivered ticks\"\n        ```\n        &lt;/center&gt;\n    \"\"\"\n\n    def calculate_next_tick_time(\n        self, *, now: int, scheduled_tick_time: int, interval: int\n    ) -&gt; int:\n        \"\"\"Calculate the next tick time.\n\n        This method always returns `scheduled_tick_time + interval`, as all\n        ticks need to produce a trigger event.\n\n        Args:\n            now: The current loop time (in microseconds).\n            scheduled_tick_time: The time the current tick was scheduled to\n                trigger (in microseconds).\n            interval: The interval between ticks (in microseconds).\n\n        Returns:\n            The next tick time (in microseconds).\n        \"\"\"\n        return scheduled_tick_time + interval\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.TriggerAllMissed-functions","title":"Functions","text":""},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.TriggerAllMissed.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this policy.</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this policy.\"\"\"\n    return f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/frequenz/channels/timer/#frequenz.channels.timer.TriggerAllMissed.calculate_next_tick_time","title":"calculate_next_tick_time","text":"<pre><code>calculate_next_tick_time(\n    *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int\n</code></pre> <p>Calculate the next tick time.</p> <p>This method always returns <code>scheduled_tick_time + interval</code>, as all ticks need to produce a trigger event.</p> PARAMETER  DESCRIPTION <code>now</code> <p>The current loop time (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>scheduled_tick_time</code> <p>The time the current tick was scheduled to trigger (in microseconds).</p> <p> TYPE: <code>int</code> </p> <code>interval</code> <p>The interval between ticks (in microseconds).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The next tick time (in microseconds).</p> Source code in <code>frequenz/channels/timer.py</code> <pre><code>def calculate_next_tick_time(\n    self, *, now: int, scheduled_tick_time: int, interval: int\n) -&gt; int:\n    \"\"\"Calculate the next tick time.\n\n    This method always returns `scheduled_tick_time + interval`, as all\n    ticks need to produce a trigger event.\n\n    Args:\n        now: The current loop time (in microseconds).\n        scheduled_tick_time: The time the current tick was scheduled to\n            trigger (in microseconds).\n        interval: The interval between ticks (in microseconds).\n\n    Returns:\n        The next tick time (in microseconds).\n    \"\"\"\n    return scheduled_tick_time + interval\n</code></pre>"},{"location":"user-guide/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Quick Start</li> <li>Installation</li> <li>Channels</li> <li>Sending</li> <li>Receiving</li> <li>Error Handling</li> <li>Utilities</li> </ul>"},{"location":"user-guide/error-handling/","title":"Error Handling","text":"<p>Base exception classes.</p>"},{"location":"user-guide/error-handling/#frequenz.channels._exceptions--exceptions","title":"Exceptions","text":"<p>All exceptions generated by this library inherit from the <code>Error</code> exception.</p> <p>Exceptions generated by channels inherit from the <code>ChannelError</code> exception. When there is an attempt to use a closed channel, a <code>ChannelClosedError</code> exception is raised.</p>"},{"location":"user-guide/error-handling/#frequenz.channels._exceptions--causes","title":"Causes","text":"<p>When a exception is caused by another exception, for example if the underlying channel was closed while seding or receiving a message, the original exception will be available as the cause of the exception:</p> <pre><code>try:\n    await sender.send(42)\nexcept SenderError as error:\n    match error.__cause__:\n        case None:\n            print(\"The message couldn't be sent for an known reason\")\n        case ChannelClosedError() as closed_error:\n            print(f\"The message couldn't be sent, channel closed: {closed_error}\")\n        case _ as unknown_error:\n            print(f\"The message couldn't be sent: {unknown_error}\")\n</code></pre> Tip <p>If you are using the async iteration interface for receivers, then you can access the cause of the <code>ReceiverStoppedError</code> exception by explicitly calling <code>receive()</code> on the receiver after the iteration is done:</p> <pre><code>async for message in receiver:\n    print(message)\ntry:\n    await receiver.receive()\nexcept ReceiverStoppedError as error:\n    print(\"The receiver was stopped\")\n    match error.__cause__:\n        case None:\n            print(\"The receiver was stopped without a known reason\")\n        case ChannelClosedError() as closed_error:\n            print(f\"The channel was closed with error: {closed_error}\")\n        case _ as unknown_error:\n            print(f\"The receiver was stopped due to an unknown error: {unknown_error}\")\n</code></pre>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul> <p>Note</p> <p>Newer Python versions and other operating systems and architectures might work too, but they are not automatically tested, so we cannot guarantee it.</p>"},{"location":"user-guide/installation/#installation_1","title":"Installation","text":"<p>First, you need to make sure you have Python installed (at least version 3.11):</p> <p>Note</p> <p>These instructions assume you are using a POSIX compatible <code>sh</code> shell.</p> <pre><code>$ python3 --version\nPython 3.11.4\n</code></pre> <p>If that command doesn't print a version newer than 3.11.0, you'll need to download and install Python first.</p> <p>To install Frequenz Channels, you probably want to create a new virtual environment first:</p> <pre><code>mkdir my-channels-project\ncd my-channels-project\npython3 -m venv .venv\n. .venv/bin/activate\n</code></pre> <p>Tip</p> <p>Using <code>direnv</code> can greatly simplify this process as it automates the creation, activation, and deactivation of the virtual environment. The first time you enable <code>direnv</code>, the virtual environment will be created, and each time you enter or leave a subdirectory, it will be activated and deactivated, respectively.</p> <pre><code>sudo apt install direnv # if you use Debian/Ubuntu\nmkdir my-channels-project\ncd my-channels-project\necho \"layout python python3\" &gt; .envrc\ndirenv allow\n</code></pre> <p>This will create the virtual environment and activate it automatically for you.</p> <p>Now you can install Frequenz Channels by using <code>pip</code> (if you don't have <code>pip</code> installed you can follow the official instructions):</p> <pre><code>python3 -m pip install frequenz-channels\n</code></pre> <p>To verify that the installation worked, you can invoke the Python interpreter and import the <code>frequenz.channels</code> module:</p> <pre><code>$ python3\nPython 3.11.4 (main, Jun  7 2023, 10:13:09) [GCC 12.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import frequenz.channels\n&gt;&gt;&gt;\n</code></pre>"},{"location":"user-guide/quick-start/","title":"Quick Start","text":""},{"location":"user-guide/quick-start/#installing","title":"Installing","text":"<p>Assuming a supported working Python environment:</p> <pre><code>python3 -m pip install frequenz-channels\n</code></pre> <p>Tip</p> <p>For more details please read the Installation Guide.</p>"},{"location":"user-guide/quick-start/#examples","title":"Examples","text":"<p>Hello World</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Anycast\n\n\nasync def main() -&gt; None:\n    hello_channel = Anycast[str](name=\"hello-world-channel\")\n    sender = hello_channel.new_sender()\n    receiver = hello_channel.new_receiver()\n\n    await sender.send(\"Hello World!\")\n    message = await receiver.receive()\n    print(message)\n\n\nasyncio.run(main())\n</code></pre> <p>Showcase</p> <p>This is a comprehensive example that shows most of the main features of the library:</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom datetime import timedelta\nfrom enum import Enum, auto\nfrom typing import assert_never\n\nfrom frequenz.channels import (\n    Anycast,\n    Broadcast,\n    Receiver,\n    Sender,\n    merge,\n    select,\n    selected_from,\n)\nfrom frequenz.channels.timer import SkipMissedAndDrift, Timer, TriggerAllMissed\n\n\nclass Command(Enum):\n    PING = auto()\n    STOP_SENDER = auto()\n\n\nclass ReplyCommand(Enum):\n    PONG = auto()\n\n\n@dataclass(frozen=True)\nclass Reply:\n    reply: ReplyCommand\n    source: str\n\n\nasync def send(\n    sender: Sender[str],\n    control_command: Receiver[Command],\n    control_reply: Sender[Reply],\n) -&gt; None:\n    \"\"\"Send a counter value every second, until a stop command is received.\"\"\"\n    print(f\"{sender}: Starting\")\n    timer = Timer(timedelta(seconds=1.0), TriggerAllMissed())\n    counter = 0\n    async for selected in select(timer, control_command):\n        if selected_from(selected, timer):\n            print(f\"{sender}: Sending {counter}\")\n            await sender.send(f\"{sender}: {counter}\")\n            counter += 1\n        elif selected_from(selected, control_command):\n            print(f\"{sender}: Received command: {selected.message.name}\")\n            match selected.message:\n                case Command.STOP_SENDER:\n                    print(f\"{sender}: Stopping\")\n                    break\n                case Command.PING:\n                    print(f\"{sender}: Ping received, reply with pong\")\n                    await control_reply.send(Reply(ReplyCommand.PONG, str(sender)))\n                case _ as unknown:\n                    assert_never(unknown)\n    print(f\"{sender}: Finished\")\n\n\nasync def receive(\n    receivers: list[Receiver[str]],\n    control_command: Receiver[Command],\n    control_reply: Sender[Reply],\n) -&gt; None:\n    \"\"\"Receive data from multiple channels, until no more data is received for 2 seconds.\"\"\"\n    print(\"receive: Starting\")\n    timer = Timer(timedelta(seconds=2.0), SkipMissedAndDrift())\n    print(f\"{timer=}\")\n    merged = merge(*receivers)\n    async for selected in select(merged, timer, control_command):\n        if selected_from(selected, merged):\n            message = selected.message\n            print(f\"receive: Received {message=}\")\n            timer.reset()\n            print(f\"{timer=}\")\n        elif selected_from(selected, control_command):\n            print(f\"receive: received command: {selected.message.name}\")\n            match selected.message:\n                case Command.PING:\n                    print(\"receive: Ping received, reply with pong\")\n                    await control_reply.send(Reply(ReplyCommand.PONG, \"receive\"))\n                case Command.STOP_SENDER:\n                    pass  # Ignore\n                case _ as unknown:\n                    assert_never(unknown)\n        elif selected_from(selected, timer):\n            drift = selected.message\n            print(\n                f\"receive: No data received for {timer.interval + drift} seconds, \"\n                \"giving up\"\n            )\n            break\n    print(\"receive: Finished\")\n\n\nasync def main() -&gt; None:\n    data_channel_1 = Anycast[str](name=\"data-channel-1\")\n    data_channel_2 = Anycast[str](name=\"data-channel-2\")\n    command_channel = Broadcast[Command](name=\"control-channel\")  # (1)!\n    reply_channel = Anycast[Reply](name=\"reply-channel\")\n\n    async with asyncio.TaskGroup() as tasks:\n        tasks.create_task(\n            send(\n                data_channel_1.new_sender(),\n                command_channel.new_receiver(),\n                reply_channel.new_sender(),\n            ),\n            name=\"send-channel-1\",\n        )\n        tasks.create_task(\n            send(\n                data_channel_2.new_sender(),\n                command_channel.new_receiver(),\n                reply_channel.new_sender(),\n            ),\n            name=\"send-channel-2\",\n        )\n        tasks.create_task(\n            receive(\n                [data_channel_1.new_receiver(), data_channel_2.new_receiver()],\n                command_channel.new_receiver(),\n                reply_channel.new_sender(),\n            ),\n            name=\"receive\",\n        )\n\n        control_sender = command_channel.new_sender()\n        reply_receiver = reply_channel.new_receiver()\n\n        # Send a ping command to all tasks and wait for the replies\n        await control_sender.send(Command.PING)\n        print(f\"main: {await reply_receiver.receive()}\")\n        print(f\"main: {await reply_receiver.receive()}\")\n        print(f\"main: {await reply_receiver.receive()}\")\n\n        await asyncio.sleep(5.0)\n\n        # Stop senders, after 2 seconds not receiving any data,\n        # the receiver will stop too\n        await control_sender.send(Command.STOP_SENDER)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/sending/","title":"Sending","text":"<p>Sender interface and related exceptions.</p>"},{"location":"user-guide/sending/#frequenz.channels._sender--senders","title":"Senders","text":"<p>Messages are sent to a channel through Sender objects. Senders are usually created by calling <code>channel.new_sender()</code>, and are a very simple abstraction that only provides a single <code>send()</code> method:</p> <pre><code>await sender.send(\"Hello, world!\")\n</code></pre> <p>Although <code>send()</code> is an asynchronous method, some channels may implement it in a synchronous, non-blocking way. For example, buffered channels that drop messages when the buffer is full could guarantee that <code>send()</code> never blocks. However, please keep in mind that the asyncio event loop could give control to another task at any time, effectively making the <code>send()</code> method blocking.</p>"},{"location":"user-guide/sending/#frequenz.channels._sender--error-handling","title":"Error Handling","text":"<p>Tip</p> <p>For more information about handling errors, please refer to the Error Handling section of the user guide.</p> <p>If there is any failure sending a message, a SenderError exception is raised.</p> <pre><code>try:\n    await sender.send(\"Hello, world!\")\nexcept SenderError as error:\n    print(f\"Error sending message: {error}\")\n</code></pre>"},{"location":"user-guide/channels/","title":"Channels","text":"<p>A channel is a communication mechanism that allows data (messages) to be transmitted between different coroutines. It consists of senders, which send messages, and receivers, which receive those messages. The channel itself acts as a conduit for these messages.</p> <p>Conceptually, a channel looks like this:</p> <p> <p> Receiver Message Message Sender Channel </p> <p></p> <p>Besides this simple model, there are many variations of channels depending on various factors:</p> <ul> <li> <p>How many senders and receivers can a channel have?</p> </li> <li> <p>Do all receivers receive all messages from all senders?</p> </li> <li> <p>How many messages can a channel hold (buffered), or can it hold any messages   at all (unbuffered)?</p> </li> <li> <p>What happens if a sender tries to send a message to a full channel?</p> <ul> <li>Does the send operation block until the channel has space again?</li> <li>Does it fail?</li> <li>Does it silently drop the message?</li> </ul> </li> </ul> <p>Because these questions can have many answers, there are different types of channels. Frequenz Channels offers a few of them:</p> <ul> <li>Anycast</li> <li>Broadcast</li> </ul> <p>More might be added in the future, and you can also create your own.</p>"},{"location":"user-guide/channels/anycast/","title":"Anycast","text":"<p>A channel that delivers each message to exactly one receiver.</p>"},{"location":"user-guide/channels/anycast/#frequenz.channels._anycast.Anycast--description","title":"Description","text":"<p>Tip</p> <p>Anycast channels behave like the Golang channels.</p> <p>Anycast channels support multiple senders and multiple receivers. Each message sent through any of the senders will be received by exactly one receiver (but any receiver).</p> <p> <p> Receiver Receiver msg1 msg1 Sender Channel Sender msg2 msg2 </p> <p></p> <p>Characteristics</p> <ul> <li>Buffered: Yes, with a global channel buffer</li> <li>Buffer full policy: Block senders</li> <li>Multiple receivers: Yes</li> <li>Multiple senders: Yes</li> <li>Thread-safe: No</li> </ul> <p>This channel is buffered, and if the senders are faster than the receivers, then the channel's buffer will fill up. In that case, the senders will block at the <code>send()</code> method until the receivers consume the messages in the channel's buffer. The channel's buffer size can be configured at creation time via the <code>limit</code> argument.</p> <p>The first receiver that is awaited will get the next message. When multiple receivers are waiting, the asyncio loop scheduler picks a receiver for each next massage.</p> <p>This means that, in practice, there might be only one receiver receiving all the messages, depending on how tasks are schduled.</p> <p>If you need to ensure some delivery policy (like round-robin or uniformly random), then you will have to implement it yourself.</p> <p>To create a new senders and receivers you can use the <code>new_sender()</code> and <code>new_receiver()</code> methods respectively.</p> <p>When the channel is not needed anymore, it should be closed with the <code>close()</code> method. This will prevent further attempts to <code>send()</code> data. Receivers will still be able to drain the pending messages on the channel, but after that, subsequent <code>receive()</code> calls will raise a <code>ReceiverStoppedError</code> exception.</p> <p>This channel is useful, for example, to distribute work across multiple workers.</p> <p>In cases where each message need to be received by every receiver, a broadcast channel may be used.</p>"},{"location":"user-guide/channels/anycast/#frequenz.channels._anycast.Anycast--examples","title":"Examples","text":"Send a few numbers to a receiver <p>This is a very simple example that sends a few numbers from a single sender to a single receiver.</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Anycast, Sender\n\n\nasync def send(sender: Sender[int]) -&gt; None:\n    for message in range(3):\n        print(f\"sending {message}\")\n        await sender.send(message)\n\n\nasync def main() -&gt; None:\n    channel = Anycast[int](name=\"numbers\")\n\n    sender = channel.new_sender()\n    receiver = channel.new_receiver()\n\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(send(sender))\n        for _ in range(3):\n            message = await receiver.receive()\n            print(f\"received {message}\")\n            await asyncio.sleep(0.1)  # sleep (or work) with the data\n\n\nasyncio.run(main())\n</code></pre> <p>The output should look something like (although the sending and received might appear more interleaved):</p> <pre><code>sending 0\nsending 1\nsending 2\nreceived 0\nreceived 1\nreceived 2\n</code></pre> Send a few number from multiple senders to multiple receivers <p>This is a more complex example that sends a few numbers from multiple senders to multiple receivers, using a small buffer to force the senders to block.</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Anycast, Receiver, ReceiverStoppedError, Sender\n\n\nasync def send(name: str, sender: Sender[int], start: int, stop: int) -&gt; None:\n    for message in range(start, stop):\n        print(f\"{name} sending {message}\")\n        await sender.send(message)\n\n\nasync def recv(name: str, receiver: Receiver[int]) -&gt; None:\n    try:\n        async for message in receiver:\n            print(f\"{name} received {message}\")\n        await asyncio.sleep(0.1)  # sleep (or work) with the data\n    except ReceiverStoppedError:\n        pass\n\n\nasync def main() -&gt; None:\n    acast = Anycast[int](name=\"numbers\", limit=2)\n\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(send(\"sender_1\", acast.new_sender(), 10, 13))\n        task_group.create_task(send(\"sender_2\", acast.new_sender(), 20, 22))\n        task_group.create_task(recv(\"receiver_1\", acast.new_receiver()))\n        task_group.create_task(recv(\"receiver_2\", acast.new_receiver()))\n\n\nasyncio.run(main())\n</code></pre> <p>The output should look something like this(although the sending and received might appear interleaved in a different way):</p> <pre><code>sender_1 sending 10\nsender_1 sending 11\nsender_1 sending 12\nAnycast channel [Anycast:numbers:_Sender] is full, blocking sender until a receiver\nconsumes a message\nsender_2 sending 20\nAnycast channel [Anycast:numbers:_Sender] is full, blocking sender until a receiver\nconsumes a message\nreceiver_1 received 10\nreceiver_1 received 11\nsender_2 sending 21\nAnycast channel [Anycast:numbers:_Sender] is full, blocking sender until a receiver\nconsumes a message\nreceiver_1 received 12\nreceiver_1 received 20\nreceiver_1 received 21\n</code></pre>"},{"location":"user-guide/channels/broadcast/","title":"Broadcast","text":"<p>A channel that deliver all messages to all receivers.</p>"},{"location":"user-guide/channels/broadcast/#frequenz.channels._broadcast.Broadcast--description","title":"Description","text":"<p>Broadcast channels can have multiple senders and multiple receivers. Each message sent through any of the senders will be received by all receivers.</p> <p> <p> Receiver Receiver msg1 msg1,msg2 Sender Channel Sender msg2 msg1,msg2 </p> <p></p> <p>Characteristics</p> <ul> <li>Buffered: Yes, with one buffer per receiver</li> <li>Buffer full policy: Drop oldest message</li> <li>Multiple receivers: Yes</li> <li>Multiple senders: Yes</li> <li>Thread-safe: No</li> </ul> <p>This channel is buffered, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped.</p> <p>Each receiver has its own buffer, so messages will only be dropped for receivers that can't keep up with the senders, and not for the whole channel.</p> <p>To create a new senders and receivers you can use the <code>new_sender()</code> and <code>new_receiver()</code> methods respectively.</p> <p>When a channel is not needed anymore, it should be closed with <code>close()</code>. This will prevent further attempts to <code>send()</code> data, and will allow receivers to drain the pending items on their queues, but after that, subsequent receive() calls will raise a <code>ReceiverStoppedError</code>.</p> <p>This channel is useful, for example, to implement a pub/sub pattern, where multiple receivers can subscribe to a channel to receive all messages.</p> <p>In cases where each message needs to be delivered only to one receiver, an anycast channel may be used.</p>"},{"location":"user-guide/channels/broadcast/#frequenz.channels._broadcast.Broadcast--examples","title":"Examples","text":"Send a few numbers to a receiver <p>This is a very simple example that sends a few numbers from a single sender to a single receiver.</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Sender\n\n\nasync def send(sender: Sender[int]) -&gt; None:\n    for message in range(3):\n        print(f\"sending {message}\")\n        await sender.send(message)\n\n\nasync def main() -&gt; None:\n    channel = Broadcast[int](name=\"numbers\")\n\n    sender = channel.new_sender()\n    receiver = channel.new_receiver()\n\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(send(sender))\n        for _ in range(3):\n            message = await receiver.receive()\n            print(f\"received {message}\")\n            await asyncio.sleep(0.1)  # sleep (or work) with the data\n\n\nasyncio.run(main())\n</code></pre> <p>The output should look something like (although the sending and received might appear more interleaved):</p> <pre><code>sending 0\nsending 1\nsending 2\nreceived 0\nreceived 1\nreceived 2\n</code></pre> Send a few number from multiple senders to multiple receivers <p>This is a more complex example that sends a few numbers from multiple senders to multiple receivers, using a small buffer to force the senders to block.</p> <pre><code>import asyncio\n\nfrom frequenz.channels import Broadcast, Receiver, ReceiverStoppedError, Sender\n\n\nasync def send(name: str, sender: Sender[int], start: int, stop: int) -&gt; None:\n    for message in range(start, stop):\n        print(f\"{name} sending {message}\")\n        await sender.send(message)\n\n\nasync def recv(name: str, receiver: Receiver[int]) -&gt; None:\n    try:\n        async for message in receiver:\n            print(f\"{name} received {message}\")\n        await asyncio.sleep(0.1)  # sleep (or work) with the data\n    except ReceiverStoppedError:\n        pass\n\n\nasync def main() -&gt; None:\n    acast = Broadcast[int](name=\"numbers\")\n\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(send(\"sender_1\", acast.new_sender(), 10, 13))\n        task_group.create_task(send(\"sender_2\", acast.new_sender(), 20, 22))\n        task_group.create_task(recv(\"receiver_1\", acast.new_receiver()))\n        task_group.create_task(recv(\"receiver_2\", acast.new_receiver()))\n\n\nasyncio.run(main())\n</code></pre> <p>The output should look something like this(although the sending and received might appear interleaved in a different way):</p> <pre><code>sender_1 sending 10\nsender_1 sending 11\nsender_1 sending 12\nsender_2 sending 20\nsender_2 sending 21\nreceiver_1 received 10\nreceiver_1 received 11\nreceiver_1 received 12\nreceiver_1 received 20\nreceiver_1 received 21\nreceiver_2 received 10\nreceiver_2 received 11\nreceiver_2 received 12\nreceiver_2 received 20\nreceiver_2 received 21\n</code></pre>"},{"location":"user-guide/receiving/","title":"Receiving","text":"<p>Receiver interface and related exceptions.</p>"},{"location":"user-guide/receiving/#frequenz.channels._receiver--receivers","title":"Receivers","text":"<p>Messages are received from channels through Receiver objects. Receivers are usually created by calling <code>channel.new_receiver()</code> and are async iterators, so the easiest way to receive messages from them as a stream is to use <code>async for</code>:</p> <pre><code>async for message in receiver:\n    print(message)\n</code></pre> <p>If you need to receive messages in different places or expecting a particular sequence, you can use the <code>receive()</code> method:</p> <pre><code>first_message = await receiver.receive()\nprint(f\"First message: {first_message}\")\n\nsecond_message = await receiver.receive()\nprint(f\"Second message: {second_message}\")\n</code></pre>"},{"location":"user-guide/receiving/#frequenz.channels._receiver--message-transformation","title":"Message Transformation","text":"<p>If you need to transform the received messages, receivers provide a <code>map()</code> method to easily do so:</p> <pre><code>async for message in receiver.map(lambda x: x + 1):\n    print(message)\n</code></pre> <p><code>map()</code> returns a new full receiver, so you can use it in any of the ways described above.</p>"},{"location":"user-guide/receiving/#frequenz.channels._receiver--error-handling","title":"Error Handling","text":"<p>Tip</p> <p>For more information about handling errors, please refer to the Error Handling section of the user guide.</p> <p>If there is an error while receiving a message, a <code>ReceiverError</code> exception is raised for both <code>receive()</code> method and async iteration interface.</p> <p>If the receiver has completely stopped (for example the underlying channel was closed), a <code>ReceiverStoppedError</code> exception is raised by <code>receive()</code> method.</p> <pre><code>try:\n    await receiver.receive()\nexcept ReceiverStoppedError as error:\n    print(\"The receiver was stopped\")\nexcept ReceiverError as error:\n    print(f\"There was an error trying to receive: {error}\")\n</code></pre> <p>When used as an async iterator, the iteration will just stop without raising an exception:</p> <pre><code>try:\n    async for message in receiver:\n        print(message)\nexcept ReceiverStoppedError as error:\n    print(\"Will never happen\")\nexcept ReceiverError as error:\n    print(f\"There was an error trying to receive: {error}\")\n# If we get here, the receiver was stopped\n</code></pre>"},{"location":"user-guide/receiving/#frequenz.channels._receiver--advanced-usage","title":"Advanced Usage","text":"<p>Warning</p> <p>This section is intended for library developers that want to build other low-level abstractions on top of channels. If you are just using channels, you can safely ignore this section.</p> <p>Receivers extend on the async iterator protocol by providing a <code>ready()</code> and a <code>consume()</code> method.</p> <p>The <code>ready()</code> method is used to await until the receiver has a new message available, but without actually consuming it. The <code>consume()</code> method consumes the next available message and returns it.</p> <p><code>ready()</code> can be called multiple times, and it will return immediately if the receiver is already ready. <code>consume()</code> must be called only after <code>ready()</code> is done and only once, until the next call to <code>ready()</code>.</p> <p>Exceptions are never raised by <code>ready()</code>, they are always delayed until <code>consume()</code> is called.</p>"},{"location":"user-guide/receiving/synchronization/","title":"Synchronization of Multiple Sources","text":"<p>If you need to receive messages from multiple sources in a synchronized way it could be difficult to, for example, receive the first message of each receiver as soon as it is available in one single task. A naive approach like this will not work:</p> <pre><code>message = await receiver1.receive()\nprint(f\"Received from channel1: {message}\")\n\nmessage = await receiver2.receive()\nprint(f\"Received from channel2: {message}\")\n</code></pre> <p>The problem is that if the first message is not available in <code>channel1</code> but in <code>channel2</code>, the program will be blocked until a message is available in <code>channel1</code>, but you probably want to receive the first message from <code>channel2</code> as soon as it is available.</p> <p>Frequenz Channels provides two tools to solve this issue: <code>merge()</code> and <code>select()</code>.</p>"},{"location":"user-guide/receiving/synchronization/merge/","title":"Merging","text":"<p>Merge messages coming from multiple receivers into a single receiver.</p>"},{"location":"user-guide/receiving/synchronization/merge/#frequenz.channels._merge--usage","title":"Usage","text":"<p>If you just need to receive the same type of messages but from multiple sources in one stream, you can use <code>merge()</code> to create a new receiver that will receive messages from all the given receivers:</p> <pre><code>async for message in merge(receiver1, receiver2):\n    print(message)\n</code></pre> <p>If the first message comes from <code>channel2</code> and the second message from <code>channel1</code>, the first message will be received immediately, and the second message will be received as soon as it is available.</p> <p>This can be helpful when you just need to receive messages and don't care about where are they coming from specifically. If you need to know where the message came from, you can use <code>select()</code> instead.</p>"},{"location":"user-guide/receiving/synchronization/merge/#frequenz.channels._merge--stopping","title":"Stopping","text":"<p>A merge receiver will be stopped automatically when all the receivers that it merges are stopped. When using the async iterator interface, this means that the iterator will stop as soon as all the receivers are stopped. When using <code>receive()</code>, this means that the method will raise a <code>ReceiverStoppedError</code> exception as soon as all the receivers are stopped.</p> <p>If you want to stop a merge receiver manually, you can use the <code>stop()</code> method.</p> <p>When using <code>receive()</code>, you should make sure to either stop all the receivers that you are merging, or to stop the merge receiver manually. This is to make sure that all the tasks created by the merge receiver are cleaned up properly.</p>"},{"location":"user-guide/receiving/synchronization/select/","title":"Selecting","text":"<p>Select the first among multiple Receivers.</p>"},{"location":"user-guide/receiving/synchronization/select/#frequenz.channels._select--usage","title":"Usage","text":"<p>If you need to receiver different types of messages from different receivers, you need to know the source of a particular received message to know the type of the message.</p> <p><code>select()</code> allows you to do that. It is an async iterator that will iterate over the messages of all receivers as they receive new messages.</p> <p>It yields a <code>Selected</code> object that will tell you the source of the received message. To make sure the received message is cast to the correct type, you need to use the <code>selected_from()</code> function to check the source of the message, and the <code>message</code> attribute to access the message:</p> <pre><code>async for selected in select(receiver1, receiver2):\n    if selected_from(selected, receiver1):\n        print(f\"Received from receiver1, next number: {selected.message + 1}\")\n    elif selected_from(selected, receiver2):\n        print(f\"Received from receiver2, length: {len(selected.message)}\")\n    else:\n        assert False, \"Unknown source, this should never happen\"\n</code></pre> Tip <p>To prevent common bugs, like when a new receiver is added to the select loop but the handling code is forgotten, <code>select()</code> will check that all the selected receivers are handled in the if-chain.</p> <p>If this happens, it will raise an <code>UnhandledSelectedError</code> exception.</p> <p>If for some reason you want to ignore a received message, just add the receiver to the if-chain and do nothing with the message:</p> <pre><code>async for selected in select(receiver1, receiver2):\n    if selected_from(selected, receiver1):\n        continue\n    if selected_from(selected, receiver2):\n        print(f\"Received from receiver2, length: {len(selected.message)}\")\n</code></pre>"},{"location":"user-guide/receiving/synchronization/select/#frequenz.channels._select--stopping","title":"Stopping","text":"<p>The <code>select()</code> async iterator will stop as soon as all the receivers are stopped. You can also end the iteration early by breaking out of the loop as normal.</p> <p>When a single receiver is stopped, it will be reported via the <code>Selected</code> object. You can use the <code>was_stopped</code> method to check if the selected receiver was stopped:</p> <pre><code>async for selected in select(receiver1, receiver2):\n    if selected_from(selected, receiver1):\n        if selected.was_stopped:\n            print(\"receiver1 was stopped\")\n            continue\n        print(f\"Received from receiver1, the next number is: {selected.message + 1}\")\n    # ...\n</code></pre> Tip <p>The <code>was_stopped</code> method is a convenience method that is equivalent to checking if the <code>exception</code> attribute is an instance of <code>ReceiverStoppedError</code>.</p>"},{"location":"user-guide/receiving/synchronization/select/#frequenz.channels._select--error-handling","title":"Error Handling","text":"Tip <p>For more information about handling errors, please refer to the Error Handling section of the user guide.</p> <p>If a receiver raises an exception while receiving a message, the exception will be raised by the <code>message</code> attribute of the <code>Selected</code> object.</p> <p>You can use a try-except block to handle exceptions as usual:</p> <pre><code>async for selected in select(receiver1, receiver2):\n    if selected_from(selected, receiver1):\n        try:\n            print(f\"Received from receiver1, next number: {selected.message + 1}\")\n        except ReceiverStoppedError:\n            print(\"receiver1 was stopped\")\n        except ValueError as value_error:\n            print(f\"receiver1 raised a ValueError: {value_error}\")\n        # ...\n    # ...\n</code></pre> <p>The <code>Selected</code> object also has a <code>exception</code> attribute that will contain the exception that was raised by the receiver.</p>"},{"location":"user-guide/utilities/events/","title":"Events","text":"<p>A receiver that can be made ready directly.</p>"},{"location":"user-guide/utilities/events/#frequenz.channels.event.Event--usage","title":"Usage","text":"<p>There are cases where it is useful to be able to send a signal to a <code>select()</code> loop, for example, to stop a loop from outside the loop itself.</p> <p>To do that, you can use an <code>Event</code> receiver and call <code>set()</code> on it when you want to make it ready.</p>"},{"location":"user-guide/utilities/events/#frequenz.channels.event.Event--stopping","title":"Stopping","text":"<p>The receiver will be re-activated (will keep blocking) after the current set event is received. To stop the receiver completely, you can call <code>stop()</code>.</p>"},{"location":"user-guide/utilities/events/#frequenz.channels.event.Event--example","title":"Example","text":"Exit after printing the first 5 numbers <pre><code>import asyncio\n\nfrom frequenz.channels import Anycast, select, selected_from\nfrom frequenz.channels.event import Event\n\nchannel: Anycast[int] = Anycast(name=\"channel\")\nreceiver = channel.new_receiver()\nsender = channel.new_sender()\nstop_event = Event(name=\"stop\")\n\n\nasync def do_work() -&gt; None:\n    async for selected in select(receiver, stop_event):\n        if selected_from(selected, receiver):\n            print(selected.message)\n        elif selected_from(selected, stop_event):\n            print(\"Stop event triggered\")\n            stop_event.stop()\n            break\n\n\nasync def send_stuff() -&gt; None:\n    for i in range(10):\n        if stop_event.is_stopped:\n            break\n        await asyncio.sleep(1)\n        await sender.send(i)\n\n\nasync def main() -&gt; None:\n    async with asyncio.TaskGroup() as task_group:\n        task_group.create_task(do_work(), name=\"do_work\")\n        task_group.create_task(send_stuff(), name=\"send_stuff\")\n        await asyncio.sleep(5.5)\n        stop_event.set()\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/utilities/file-watchers/","title":"File Watchers","text":"<p>A receiver that watches for file events.</p>"},{"location":"user-guide/utilities/file-watchers/#frequenz.channels.file_watcher.FileWatcher--usage","title":"Usage","text":"<p>A <code>FileWatcher</code> receiver can be used to watch for changes in a set of files. It will generate an <code>Event</code> message every time a file is created, modified or deleted, depending on the type of events that it is configured to watch for.</p> <p>The event message contains the <code>type</code> of change that was observed and the <code>path</code> where the change was observed.</p>"},{"location":"user-guide/utilities/file-watchers/#frequenz.channels.file_watcher.FileWatcher--event-types","title":"Event Types","text":"<p>The following event types are available:</p> <ul> <li><code>CREATE</code>:     The file was created.</li> <li><code>MODIFY</code>:     The file was modified.</li> <li><code>DELETE</code>:     The file was deleted.</li> </ul>"},{"location":"user-guide/utilities/file-watchers/#frequenz.channels.file_watcher.FileWatcher--example","title":"Example","text":"Watch for changes and exit after the file is modified <pre><code>import asyncio\n\nfrom frequenz.channels.file_watcher import EventType, FileWatcher\n\nPATH = \"/tmp/test.txt\"\nfile_watcher = FileWatcher(paths=[PATH], event_types=[EventType.MODIFY])\n\n\nasync def update_file() -&gt; None:\n    await asyncio.sleep(1)\n    with open(PATH, \"w\", encoding=\"utf-8\") as file:\n        file.write(\"Hello, world!\")\n\n\nasync def main() -&gt; None:\n    # Create file\n    with open(PATH, \"w\", encoding=\"utf-8\") as file:\n        file.write(\"Hello, world!\")\n    async with asyncio.TaskGroup() as group:\n        group.create_task(update_file())\n        async for event in file_watcher:\n            print(f\"File {event.path}: {event.type.name}\")\n            break\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/utilities/timers/","title":"Timers","text":"<p>A receiver that sends a message regularly.</p>"},{"location":"user-guide/utilities/timers/#frequenz.channels.timer--quick-start","title":"Quick Start","text":"Important <p>This quick start is provided to have a quick feeling of how to use this module, but it is extremely important to understand how timers behave when they are delayed.</p> <p>We recommend emphatically to read about missed ticks and drifting before using timers in production.</p> <p>If you need to do something as periodically as possible (avoiding drifts), you can use a <code>Timer</code> like this:</p> Periodic Timer Example <pre><code>import asyncio\nfrom datetime import datetime, timedelta\n\nfrom frequenz.channels.timer import Timer\n\n\nasync def main() -&gt; None:\n    async for drift in Timer(timedelta(seconds=1.0), TriggerAllMissed()):\n        print(f\"The timer has triggered at {datetime.now()} with a drift of {drift}\")\n\n\nasyncio.run(main())\n</code></pre> <p>This timer will tick as close as every second as possible, even if the loop is busy doing something else for a good amount of time. In extreme cases, if the loop was busy for a few seconds, the timer will trigger a few times in a row to catch up, one for every missed tick.</p> <p>If, instead, you need a timeout, for example to abort waiting for other receivers after a certain amount of time, you can use a <code>Timer</code> like this:</p> Timeout Example <pre><code>import asyncio\nfrom datetime import timedelta\n\nfrom frequenz.channels import Anycast, select, selected_from\nfrom frequenz.channels.timer import Timer\n\n\nasync def main() -&gt; None:\n    channel = Anycast[int](name=\"data-channel\")\n    data_receiver = channel.new_receiver()\n\n    timer = Timer(timedelta(seconds=1.0), SkipMissedAndDrift())\n\n    async for selected in select(data_receiver, timer):\n        if selected_from(selected, data_receiver):\n            print(f\"Received data: {selected.message}\")\n            timer.reset()\n        elif selected_from(selected, timer):\n            drift = selected.message\n            print(f\"No data received for {timer.interval + drift} seconds, giving up\")\n            break\n\n\nasyncio.run(main())\n</code></pre> <p>This timer will rearm itself automatically after it was triggered, so it will trigger again after the selected interval, no matter what the current drift was. So if the loop was busy for a few seconds, the timer will trigger immediately and then wait for another second before triggering again. The missed ticks are skipped.</p>"},{"location":"user-guide/utilities/timers/#frequenz.channels.timer--missed-ticks-and-drifting","title":"Missed Ticks And Drifting","text":"<p>A <code>Timer</code> can be used to send a messages at regular time intervals, but there is one fundamental issue with timers in the asyncio world: the event loop could give control to another task at any time, and that task can take a long time to finish, making the time it takes the next timer message to be received longer than the desired interval.</p> <p>Because of this, it is very important for users to be able to understand and control how timers behave when they are delayed. Timers will handle missed ticks according to a missing tick policy.</p> <p>The following built-in policies are available:</p> <ul> <li><code>SkipMissedAndDrift</code>:     A policy that drops all the missed ticks, triggers immediately and resets.</li> <li><code>SkipMissedAndResync</code>:     A policy that drops all the missed ticks, triggers immediately and resyncs.</li> <li><code>TriggerAllMissed</code>:     A policy that triggers all the missed ticks immediately until it catches up.</li> </ul>"},{"location":"user-guide/utilities/timers/#policies","title":"Policies","text":""},{"location":"user-guide/utilities/timers/#skip-missed-and-drift","title":"Skip Missed And Drift","text":"<p>A policy that drops all the missed ticks, triggers immediately and resets.</p> <p>The <code>SkipMissedAndDrift</code> policy will behave effectively as if the timer was reset every time it is triggered. This means the start time will change and the drift will be accumulated each time a tick is delayed. Only the relative drift will be returned on each tick.</p> <p>The reset happens only if the delay is larger than the delay tolerance, so it is possible to ignore small delays and not drift in those cases.</p> Example <p>This example represents a timer with interval 1 second and delay tolerance of 0.1 seconds.</p> <ol> <li> <p>The first tick, <code>T0</code>, happens exactly at time 0.</p> </li> <li> <p>The second tick, <code>T1.2</code>, happens at time 1.2 (0.2 seconds late), so the timer     triggers immediately but drifts a bit (0.2 seconds), so the next tick is     expected at 2.2 seconds.</p> </li> <li> <p>The third tick, <code>T2.2</code>, happens at 2.3 seconds (0.1 seconds late), so it also     triggers immediately but it doesn't drift because the delay is under     the <code>delay_tolerance</code>. The next tick is expected at 3.2 seconds.</p> </li> <li> <p>The fourth tick, <code>T4.2</code>, triggers at 4.3 seconds (1.1 seconds late), so it     also triggers immediately but the timer has drifted by 1.1 seconds, so a     potential tick <code>T3.2</code> is skipped (not triggered).</p> </li> <li> <p>The fifth tick, <code>T5.3</code>, triggers at 5.3 seconds so it is right on time (no     drift) and the same happens for tick <code>T6.3</code>, which triggers at 6.3 seconds.</p> </li> </ol> <p> <p> 0 1 2 3 4 5 6 T0 T1.2 T2.2 T3.2 T4.2 T5.3 T6.3 time Expected ticks Delivered ticks Undelivered ticks (skipped) </p> <p></p>"},{"location":"user-guide/utilities/timers/#skip-missed-and-re-sync","title":"Skip Missed And Re-Sync","text":"<p>A policy that drops all the missed ticks, triggers immediately and resyncs.</p> <p>If ticks are missed, the <code>SkipMissedAndResync</code> policy will make the <code>Timer</code> trigger immediately and it will schedule to trigger again on the next multiple of the interval, effectively skipping any missed ticks, but re-syncing with the original start time.</p> Example <p>This example represents a timer with interval 1 second.</p> <ol> <li> <p>The first tick <code>T0</code> happens exactly at time 0.</p> </li> <li> <p>The second tick, <code>T1</code>, happens at time 1.2 (0.2 seconds late), so it triggers     immediately. But it re-syncs, so the next tick is still expected at     2 seconds. This re-sync happens on every tick, so all ticks are expected at     multiples of 1 second, not matter how delayed they were.</p> </li> <li> <p>The third tick, <code>T2</code>, happens at time 2.3 (0.3 seconds late), so it also     triggers immediately.</p> </li> <li> <p>The fourth tick, <code>T3</code>, happens at time 4.3 (1.3 seconds late), so it also     triggers immediately, but there was also a tick expected at 4 seconds, <code>T4</code>,     which is skipped according to this policy to avoid bursts of ticks.</p> </li> <li> <p>The sixth tick, <code>T5</code>, happens at 5.1 (0.1 seconds late), so it triggers     immediately again.</p> </li> <li> <p>The seventh tick, <code>T6</code>, happens at 6.0, right on time.</p> </li> </ol> <p> <p> 0 1 2 3 4 T4 5 6 T0 T1 T2 T3 T5 T6 time Expected ticks Delivered ticks Undelivered ticks (skipped) </p> <p></p>"},{"location":"user-guide/utilities/timers/#trigger-all-missed","title":"Trigger All Missed","text":"<p>A policy that triggers all the missed ticks immediately until it catches up.</p> <p>The <code>TriggerAllMissed</code> policy will trigger all missed ticks immediately until it catches up with the current time. This means that if the timer is delayed for any reason, when it finally gets some time to run, it will trigger all the missed ticks in a burst. The drift is not accumulated and the next tick will be scheduled according to the original start time.</p> Example <p>This example represents a timer with interval 1 second.</p> <ol> <li> <p>The first tick, <code>T0</code> happens exactly at time 0.</p> </li> <li> <p>The second tick, <code>T1</code>, happens at time 1.2 (0.2 seconds late), so it triggers     immediately. But it re-syncs, so the next tick is still expected at     2 seconds. This re-sync happens on every tick, so all ticks are expected at     multiples of 1 second, not matter how delayed they were.</p> </li> <li> <p>The third tick, <code>T2</code>, happens at time 2.3 (0.3 seconds late), so it also     triggers immediately.</p> </li> <li> <p>The fourth tick, <code>T3</code>, happens at time 4.3 (1.3 seconds late), so it also     triggers immediately.</p> </li> <li> <p>The fifth tick, <code>T4</code>, which was also already delayed (by 0.3 seconds),     triggers immediately too, resulting in a small catch-up burst.</p> </li> <li> <p>The sixth tick, <code>T5</code>, happens at 5.1 (0.1 seconds late), so it triggers     immediately again.</p> </li> <li> <p>The seventh tick, <code>T6</code>, happens at 6.0, right on time.</p> </li> </ol> <p> <p> 0 1 2 3 4 T4 5 6 T0 T1 T2 T3 T5 T6 time Expected ticks Delivered ticks </p> <p></p>"},{"location":"user-guide/utilities/timers/#timer","title":"Timer","text":"<p>A receiver that sends a message regularly.</p> <p><code>Timer</code>s are started by default after they are created. This can be disabled by using <code>auto_start=False</code> option when creating them. In this case, the timer will not be started until <code>reset()</code> is called. Receiving from the timer (either using <code>receive()</code> or using the async iterator interface) will also start the timer at that point.</p> <p>Timers need to be created in a context where a <code>asyncio</code> loop is already running. If no <code>loop</code> is specified, the current running loop is used.</p> <p>Timers can be stopped by calling <code>stop()</code>. A stopped timer will raise a <code>ReceiverStoppedError</code> or stop the async iteration as usual.</p> <p>Once a timer is explicitly stopped, it can only be started again by explicitly calling <code>reset()</code> (trying to receive from it or using the async iterator interface will keep failing).</p> <p>Timer messages are <code>timedelta</code>s containing the drift of the timer, i.e. the difference between when the timer should have triggered and the time when it actually triggered.</p> <p>This drift will likely never be <code>0</code>, because if there is a task that is running when it should trigger, the timer will be delayed. In this case the drift will be positive. A negative drift should be technically impossible, as the timer uses <code>asyncio</code>s loop monotonic clock.</p> Warning <p>Even when the <code>asyncio</code> loop's monotonic clock is a <code>float</code>, timers use <code>int</code>s to represent time internally. The internal time is tracked in microseconds, so the timer resolution is 1 microsecond (<code>interval</code> must be at least  1 microsecond).</p> <p>This is to avoid floating point errors when performing calculations with time, which can lead to issues that are very hard to reproduce and debug.</p> <p>If the timer is delayed too much, then it will behave according to the <code>missed_tick_policy</code>. Missing ticks might or might not trigger a message and the drift could be accumulated or not depending on the chosen policy.</p>"},{"location":"user-guide/utilities/timers/#custom-missed-tick-policies","title":"Custom Missed Tick Policies","text":"<p>A policy to handle timer missed ticks.</p> <p>To implement a custom policy you need to subclass <code>MissedTickPolicy</code> and implement the <code>calculate_next_tick_time</code> method.</p> Example <p>This policy will just wait one more second than the original interval if a tick is missed:</p> <pre><code>class WaitOneMoreSecond(MissedTickPolicy):\n    def calculate_next_tick_time(\n        self, *, interval: int, scheduled_tick_time: int, now: int\n    ) -&gt; int:\n        return scheduled_tick_time + interval + 1_000_000\n\n\nasync def main() -&gt; None:\n    timer = Timer(\n        interval=timedelta(seconds=1),\n        missed_tick_policy=WaitOneMoreSecond(),\n    )\n\n    async for drift in timer:\n        print(f\"The timer has triggered with a drift of {drift}\")\n\nasyncio.run(main())\n</code></pre>"}]}